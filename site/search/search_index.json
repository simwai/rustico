{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quick Links","text":"<ul> <li>Quick Start</li> <li>API Reference</li> <li>Examples</li> <li>Comparison with Other Libraries</li> <li>Contributing</li> </ul>"},{"location":"comparison/","title":"Comparison with Other Libraries","text":"<p>This page compares <code>rustico</code> with other similar libraries in the Python ecosystem.</p>"},{"location":"comparison/#feature-comparison","title":"Feature Comparison","text":"Library Ok/Err do-notation Async Decorators Type Guards Tracebacks Type Hints Monads Rust-like Philosophy Size rustico \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 CUPID, explicit Small result \u2705 \u274c \u274c \u274c \u274c \u274c \u2705 Partial \u2705 Simplicity Tiny returns \u2705 Partial \u2705 \u2705 \u2705 \u274c \u2705 \u2705 Partial Functional Large poltergeist \u2705 \u274c \u274c \u274c \u274c \u274c \u2705 \u274c \u2705 Minimalism Tiny rusty-errors \u2705 \u274c \u274c \u274c \u274c \u274c \u2705 Partial \u2705 Rust-inspired Small <p>Legend:</p> <ul> <li>do-notation: Generator-based early-exit chaining</li> <li>Async: Native async/await support</li> <li>Decorators: Built-in function wrapping decorators</li> <li>Type Guards: <code>is_ok</code>, <code>is_err</code> for static analysis</li> <li>Tracebacks: Captures exception tracebacks in <code>Err</code></li> <li>Monads: Supports chaining, mapping, flatMap operations</li> <li>Rust-like: API and philosophy inspired by Rust</li> </ul>"},{"location":"comparison/#detailed-comparison","title":"Detailed Comparison","text":""},{"location":"comparison/#rustico-this-library","title":"rustico (This Library)","text":"<ul> <li>Strengths: Full-featured, async-first, excellent TypeScript-like developer experience</li> <li>Philosophy: CUPID principle - Composable, Unix-like, Predictable, Idiomatic, Declarative</li> <li>Best for: New projects, async workflows, teams wanting explicit error handling</li> <li>Unique features: Traceback capture, do-notation, dual-mode decorators</li> </ul>"},{"location":"comparison/#result","title":"result","text":"<ul> <li>Strengths: Simple, lightweight, battle-tested</li> <li>Philosophy: Keep it simple and close to Rust's API</li> <li>Best for: Simple sync applications, minimal dependencies</li> <li>Limitations: No async support, no decorators, basic feature set</li> </ul>"},{"location":"comparison/#returns","title":"returns","text":"<ul> <li>Strengths: Rich functional programming features, extensive ecosystem</li> <li>Philosophy: Bring functional programming concepts to Python</li> <li>Best for: FP enthusiasts, complex data transformation pipelines</li> <li>Unique features: Maybe, IO, containers, railway-oriented programming</li> <li>Limitations: Learning curve, heavy dependency</li> </ul>"},{"location":"comparison/#poltergeist","title":"poltergeist","text":"<ul> <li>Strengths: Extremely minimal, zero dependencies</li> <li>Philosophy: Minimalism above all</li> <li>Best for: Embedded systems, minimal footprint requirements</li> <li>Limitations: Very basic feature set, no advanced operations</li> </ul>"},{"location":"comparison/#rusty-errors","title":"rusty-errors","text":"<ul> <li>Strengths: Close to Rust's Result API</li> <li>Philosophy: Direct Rust port</li> <li>Best for: Rust developers transitioning to Python</li> <li>Limitations: Limited Python-specific features, no async</li> </ul>"},{"location":"comparison/#code-comparison","title":"Code Comparison","text":""},{"location":"comparison/#basic-usage","title":"Basic Usage","text":""},{"location":"comparison/#rustico","title":"rustico","text":"<pre><code>from rustico import Ok, Err, as_result\n\n@as_result(ValueError)\ndef parse_int(s: str) -&gt; int:\n    return int(s)\n\nresult = parse_int(\"123\")\nif result.is_ok():\n    print(result.unwrap())  # 123\nelse:\n    print(f\"Error: {result.unwrap_err()}\")\n</code></pre>"},{"location":"comparison/#result_1","title":"result","text":"<pre><code>from result import Ok, Err, Result\n\ndef parse_int(s: str) -&gt; Result[int, ValueError]:\n    try:\n        return Ok(int(s))\n    except ValueError as e:\n        return Err(e)\n\nresult = parse_int(\"123\")\nif result.is_ok():\n    print(result.unwrap())  # 123\nelse:\n    print(f\"Error: {result.unwrap_err()}\")\n</code></pre>"},{"location":"comparison/#returns_1","title":"returns","text":"<pre><code>from returns.result import Success, Failure, Result\nfrom returns.functions import raise_exception\n\ndef parse_int(s: str) -&gt; Result[int, ValueError]:\n    try:\n        return Success(int(s))\n    except ValueError as e:\n        return Failure(e)\n\nresult = parse_int(\"123\")\nresult.map(print)  # 123\nresult.alt(raise_exception)\n</code></pre>"},{"location":"comparison/#chaining-operations","title":"Chaining Operations","text":""},{"location":"comparison/#rustico_1","title":"rustico","text":"<pre><code>from rustico import Ok, Err, do\n\n@do\ndef process():\n    x = yield parse_int(\"10\")\n    y = yield parse_int(\"20\")\n    return x + y\n\nresult = process()\nprint(result)  # Ok(30)\n</code></pre>"},{"location":"comparison/#result_2","title":"result","text":"<pre><code>from result import Ok, Err\n\ndef process():\n    x_result = parse_int(\"10\")\n    if x_result.is_err():\n        return x_result\n\n    y_result = parse_int(\"20\")\n    if y_result.is_err():\n        return y_result\n\n    return Ok(x_result.unwrap() + y_result.unwrap())\n\nresult = process()\nprint(result)  # Ok(30)\n</code></pre>"},{"location":"comparison/#returns_2","title":"returns","text":"<pre><code>from returns.result import Success, Failure\nfrom returns.functions import raise_exception\n\ndef process():\n    return parse_int(\"10\").bind(\n        lambda x: parse_int(\"20\").map(\n            lambda y: x + y\n        )\n    )\n\nresult = process()\nprint(result)  # Success(30)\n</code></pre>"},{"location":"comparison/#why-choose-rustico","title":"Why Choose rustico?","text":"<ul> <li>Balanced Approach: Not too minimal, not too complex</li> <li>Async-First: Built with modern async Python in mind</li> <li>Developer Experience: Excellent type hints and IDE integration</li> <li>Explicit Error Handling: Makes error cases impossible to ignore</li> <li>Traceback Capture: Preserves stack traces for better debugging</li> <li>Pattern Matching: First-class support for Python 3.10+ pattern matching</li> <li>Composable: Easy to chain operations with do-notation</li> <li>Rust-Inspired: Familiar API for Rust developers</li> </ul> <p>Choose <code>rustico</code> if you want a modern, well-balanced Result type implementation that works well with both synchronous and asynchronous code, provides excellent developer experience, and makes error handling explicit and composable.</p>"},{"location":"contributing/","title":"Contributing to rustico","text":"<p>Thank you for your interest in contributing to <code>rustico</code>! This document provides guidelines and instructions for contributing to the project.</p>"},{"location":"contributing/#development-environment-setup","title":"Development Environment Setup","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork locally</li> <li>Set up the development environment:</li> </ol> <pre><code># Install PDM if you don't have it\npip install pdm\n\n# Install development dependencies\npdm install\n</code></pre>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":"<ol> <li>Create a new branch for your feature or bugfix:</li> </ol> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> <ol> <li>Make your changes and write tests for them</li> <li>Run the tests to ensure everything works:</li> </ol> <pre><code>pdm test\n</code></pre> <ol> <li>Format your code:</li> </ol> <pre><code>pdm format\n</code></pre> <ol> <li>Commit your changes with a descriptive commit message</li> <li>Push your branch to your fork</li> <li>Create a pull request to the main repository</li> </ol>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We follow PEP 8 guidelines with a few modifications. The project uses Ruff for linting and formatting.</p> <p>Key style points:</p> <ul> <li>Use type hints for all function parameters and return values</li> <li>Write docstrings for all public functions, classes, and methods</li> <li>Keep lines under 100 characters</li> <li>Use descriptive variable names</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<p>All new features should include tests. We use pytest for testing.</p> <ul> <li>Write unit tests for all new functionality</li> <li>Ensure all tests pass before submitting a pull request</li> <li>Aim for high test coverage</li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Documentation is crucial for <code>rustico</code>. When adding new features:</p> <ul> <li>Update docstrings with clear explanations and examples</li> <li>Add type hints that work well with static type checkers</li> <li>Consider adding examples to the documentation</li> </ul>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Ensure your code passes all tests</li> <li>Update the documentation if needed</li> <li>Add your changes to the CHANGELOG.md file</li> <li>Submit a pull request with a clear description of the changes</li> <li>Address any feedback from code reviews</li> </ol>"},{"location":"contributing/#release-process","title":"Release Process","text":"<p>Releases are managed by the maintainers. The general process is:</p> <ol> <li>Update version in pyproject.toml</li> <li>Update CHANGELOG.md</li> <li>Create a new release on GitHub</li> <li>Publish to PyPI</li> </ol>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please be respectful and considerate of others when contributing to the project. We aim to foster an inclusive and welcoming community.</p>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing to <code>rustico</code>, you agree that your contributions will be licensed under the project's MIT license.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page contains practical examples of using <code>rustico</code> in real-world scenarios.</p> <p>About these examples</p> <p>These examples demonstrate real-world use cases for <code>rustico</code>. They're designed to be copy-paste friendly and show best practices for error handling.</p> <p>Pro tip</p> <p>Most examples use the <code>@do</code> decorator for composing operations. This is the recommended approach for complex workflows.</p> <p>Get Started with Examples View on GitHub</p>"},{"location":"examples/#web-api-client","title":"Web API Client","text":"<p> Use Case: Making HTTP requests with proper error handling</p> <pre><code>import requests\nfrom rustico import as_result, do, Ok, Err, Result\n\n@as_result(requests.RequestException)\ndef fetch_user(user_id: int) -&gt; dict:\n    response = requests.get(f\"https://api.example.com/users/{user_id}\")\n    response.raise_for_status()\n    return response.json()\n\n@as_result(KeyError, TypeError)\ndef extract_email(user_data: dict) -&gt; str:\n    return user_data[\"email\"]\n\n@do\ndef get_user_email(user_id: int) -&gt; Result[str, Exception]:\n    user_data = yield fetch_user(user_id)\n    email = yield extract_email(user_data)\n    return email.lower()\n\n# Usage\nresult = get_user_email(123)\nmatch result:\n    case Ok(email):\n        print(f\"User email: {email}\")\n    case Err(error):\n        if isinstance(error, requests.ConnectionError):\n            print(\"Network error. Please check your connection.\")\n        elif isinstance(error, requests.HTTPError):\n            print(f\"API error: {error}\")\n        elif isinstance(error, KeyError):\n            print(\"User data is missing email field\")\n        else:\n            print(f\"Unexpected error: {error}\")\n</code></pre>"},{"location":"examples/#database-operations","title":"Database Operations","text":"<p> Use Case: Safe database interactions with automatic connection handling</p> <pre><code>import sqlite3\nfrom typing import List\nfrom rustico import as_result, do, Ok, Err, Result\n\n@as_result(sqlite3.Error)\ndef connect_db(db_path: str) -&gt; sqlite3.Connection:\n    return sqlite3.connect(db_path)\n\n@as_result(sqlite3.Error)\ndef execute_query(conn: sqlite3.Connection, query: str, params: tuple = ()) -&gt; List[tuple]:\n    cursor = conn.cursor()\n    cursor.execute(query, params)\n    return cursor.fetchall()\n\n@do\ndef get_user_posts(db_path: str, user_id: int) -&gt; Result[List[dict], Exception]:\n    conn = yield connect_db(db_path)\n\n    try:\n        rows = yield execute_query(\n            conn, \n            \"SELECT id, title, content FROM posts WHERE user_id = ?\", \n            (user_id,)\n        )\n\n        posts = [\n            {\"id\": row[0], \"title\": row[1], \"content\": row[2]}\n            for row in rows\n        ]\n\n        return posts\n    finally:\n        conn.close()\n\n# Usage\nresult = get_user_posts(\"app.db\", 42)\nif result.is_ok():\n    posts = result.unwrap()\n    print(f\"Found {len(posts)} posts\")\n    for post in posts:\n        print(f\"- {post['title']}\")\nelse:\n    print(f\"Database error: {result.unwrap_err()}\")\n</code></pre>"},{"location":"examples/#file-operations","title":"File Operations","text":"<p> Use Case: Reading and parsing configuration files safely</p> <pre><code>import json\nfrom pathlib import Path\nfrom rustico import as_result, do, Ok, Err, Result\n\n@as_result(FileNotFoundError, PermissionError)\ndef read_file(path: str) -&gt; str:\n    return Path(path).read_text(encoding=\"utf-8\")\n\n@as_result(json.JSONDecodeError)\ndef parse_json(content: str) -&gt; dict:\n    return json.loads(content)\n\n@do\ndef load_config(config_path: str) -&gt; Result[dict, Exception]:\n    content = yield read_file(config_path)\n    config = yield parse_json(content)\n\n    # Validate config\n    if \"api_key\" not in config:\n        return Err(ValueError(\"Missing required 'api_key' in config\"))\n\n    return config\n\n# Usage\nresult = load_config(\"config.json\")\nconfig = result.unwrap_or({\n    \"api_key\": \"default_key\",\n    \"timeout\": 30,\n    \"debug\": False\n})\n\nprint(f\"Using API key: {config['api_key']}\")\n</code></pre>"},{"location":"examples/#error-handling-patterns","title":"Error Handling Patterns","text":"<p>Common Pitfalls</p> <p>Remember that <code>unwrap()</code> will raise an exception if called on an <code>Err</code> result. Always check with <code>is_ok()</code> first or use <code>unwrap_or()</code> if you need a fallback value.</p>"},{"location":"examples/#fallback-values","title":"Fallback Values","text":"<pre><code>from rustico import as_result, Ok, Err\n\n@as_result(ValueError)\ndef parse_int(s: str) -&gt; int:\n    return int(s)\n\n# Using unwrap_or for fallback\nport = parse_int(os.environ.get(\"PORT\", \"\")).unwrap_or(8080)\nprint(f\"Starting server on port {port}\")\n</code></pre>"},{"location":"examples/#transforming-errors","title":"Transforming Errors","text":"<pre><code>from rustico import as_result, Ok, Err\n\n@as_result(ValueError)\ndef parse_int(s: str) -&gt; int:\n    return int(s)\n\n# Transform error to a user-friendly message\nresult = parse_int(\"abc\").map_err(lambda e: f\"Invalid number format: {e}\")\nprint(result)  # Err('Invalid number format: ...')\n</code></pre>"},{"location":"examples/#collecting-results","title":"Collecting Results","text":"<pre><code>from rustico import Ok, Err\n\ndef process_items(items: list) -&gt; list:\n    results = [process_item(item) for item in items]\n\n    # Filter out successful results\n    successful = [result.unwrap() for result in results if result.is_ok()]\n\n    # Collect errors\n    errors = [result.unwrap_err() for result in results if result.is_err()]\n\n    if errors:\n        print(f\"Warning: {len(errors)} items failed processing\")\n\n    return successful\n\ndef process_item(item):\n    # Process the item and return Ok or Err\n    pass\n</code></pre>"},{"location":"examples/#advanced-pattern-matching","title":"Advanced Pattern Matching","text":"<p>Python 3.10+ Feature</p> <p>Pattern matching requires Python 3.10 or later. For earlier versions, use conditional checks with <code>is_ok()</code> and <code>is_err()</code>.</p> <pre><code>from rustico import Ok, Err, as_result\n\n@as_result(ValueError, ZeroDivisionError)\ndef divide(a: int, b: int) -&gt; float:\n    return a / b\n\nresult = divide(10, 0)\n\nmatch result:\n    case Ok(value):\n        print(f\"Result: {value}\")\n    case Err(ZeroDivisionError() as e):\n        print(f\"Division by zero error: {e}\")\n    case Err(ValueError() as e):\n        print(f\"Value error: {e}\")\n    case Err(e):\n        print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"examples/#working-with-external-libraries","title":"Working with External Libraries","text":"<p>Integration Pattern</p> <p>When working with libraries that use exceptions, wrap their functions with <code>as_result</code> or use a try/except block that returns <code>Ok</code>/<code>Err</code>.</p> <pre><code>from rustico import Ok, Err, Result\nimport requests\n\ndef fetch_data(url: str) -&gt; Result[dict, Exception]:\n    try:\n        response = requests.get(url, timeout=5)\n        response.raise_for_status()\n        return Ok(response.json())\n    except requests.RequestException as e:\n        return Err(e)\n\n# Usage\nresult = fetch_data(\"https://api.example.com/data\")\ndata = result.unwrap_or({})\n</code></pre> <p>These examples demonstrate how <code>rustico</code> can be used in various real-world scenarios to make error handling more explicit, composable, and maintainable.</p>"},{"location":"examples/#feature-comparison","title":"Feature Comparison","text":"Feature Traditional Try/Except rustico Error Propagation Manual re-raising Automatic with <code>@do</code> Error Information Often lost in translation Preserved exactly Composability Nested try/except blocks Chainable operations Type Safety No static analysis Full type hints Pattern Matching Not applicable Native support Readability Often verbose and nested Linear and clear"},{"location":"examples/#next-steps","title":"Next Steps","text":"<ul> <li>Read the Quick Start guide for more examples</li> <li>Check the API Reference for detailed documentation</li> <li>Contribute to rustico to help improve the library</li> </ul> <p>Back to Top</p>"},{"location":"quickstart/","title":"Quick Start","text":"<p>This guide will help you get started with <code>rustico</code> quickly. We'll cover the basics of using the <code>Result</code> type and show you how it compares to traditional error handling.</p>"},{"location":"quickstart/#the-problem-with-traditional-error-handling","title":"The Problem with Traditional Error Handling","text":"<p>Traditional error handling in Python using try/except blocks can be verbose, error-prone, and difficult to compose:</p> <pre><code>def process_user_data(user_id: str, age_str: str):\n    try:\n        user_id_int = int(user_id)\n    except ValueError:\n        return None  # Lost error information!\n\n    try:\n        age = int(age_str)\n    except ValueError:\n        return None  # Which field failed?\n\n    try:\n        if age &lt; 0:\n            raise ValueError(\"Age cannot be negative\")\n        return {\"user_id\": user_id_int, \"age\": age}\n    except ValueError:\n        return None  # Nested try/except hell!\n\n# Usage - You have to remember to check for None!\nresult = process_user_data(\"123\", \"25\")\nif result is None:  # But WHY did it fail?\n    print(\"Something went wrong...\")\n</code></pre>"},{"location":"quickstart/#the-rustico-way","title":"The <code>rustico</code> Way","text":"<p>With <code>rustico</code>, error handling becomes explicit, composable, and clear:</p> <pre><code>from rustico import as_result, do, Ok, Err\n\n@as_result(ValueError)\ndef parse_int(s: str) -&gt; int:\n    return int(s)\n\n@do\ndef process_user_data(user_id: str, age_str: str):\n    # Each step is explicit and composable\n    user_id_int = yield parse_int(user_id)\n    age = yield parse_int(age_str)\n\n    if age &lt; 0:\n        return Err(\"Age cannot be negative\")\n\n    return {\"user_id\": user_id_int, \"age\": age}\n\n# Usage - Errors are explicit and informative\nresult = process_user_data(\"123\", \"25\")\nmatch result:\n    case Ok(data):\n        print(f\"Success: {data}\")\n    case Err(error):\n        print(f\"Failed because: {error}\")\n</code></pre>"},{"location":"quickstart/#basic-usage-examples","title":"Basic Usage Examples","text":""},{"location":"quickstart/#1-wrapping-functions","title":"1. Wrapping Functions","text":"<pre><code>from rustico import as_result\n\n@as_result(ValueError)\ndef parse_int(s: str) -&gt; int:\n    return int(s)\n\nprint(parse_int(\"123\"))    # Ok(123)\nprint(parse_int(\"oops\"))   # Err(ValueError(...))\n</code></pre>"},{"location":"quickstart/#2-handling-results","title":"2. Handling Results","text":"<pre><code>result = parse_int(\"456\")\nif result.is_ok():\n    value = result.unwrap()\n    print(\"Got:\", value)\nelse:\n    error = result.unwrap_err()\n    print(\"Failed:\", error)\n</code></pre>"},{"location":"quickstart/#3-chaining-operations","title":"3. Chaining Operations","text":"<pre><code>from rustico import Ok, Err\n\ndef double(x: int):\n    return Ok(x * 2)\n\nresult = parse_int(\"21\").and_then(double)\nprint(result)  # Ok(42)\n</code></pre>"},{"location":"quickstart/#composing-multiple-steps-do-notation","title":"Composing Multiple Steps (do-notation)","text":"<pre><code>from rustico import as_result, do\n\n@do\ndef example():\n    # This yields Result[int, ValueError]\n    x = yield Ok(10)  # x receives the unwrapped int (type T)\n    y = yield Ok(20)  # y receives the unwrapped int (type T)\n    return x + y     \n\nprint(example())  # Ok(30)\n</code></pre>"},{"location":"quickstart/#early-exit-on-error","title":"Early Exit on Error","text":"<pre><code>@do\ndef safe_division(a: str, b: str):\n    x = yield parse_int(a)\n    y = yield parse_int(b)\n    if y == 0:\n        return Err(\"Division by zero\")\n    return x / y\n\nprint(safe_division(\"100\", \"0\"))   # Err('Division by zero')\nprint(safe_division(\"100\", \"5\"))   # Ok(20.0)\nprint(safe_division(\"foo\", \"5\"))   # Err(ValueError(...))\n</code></pre>"},{"location":"quickstart/#async-example","title":"Async Example","text":"<pre><code>import asyncio\nfrom rustico import as_async_result, do_async\n\n@as_async_result(ValueError)\nasync def parse_int_async(s: str) -&gt; int:\n    await asyncio.sleep(0.1)\n    return int(s)\n\n@do_async\nasync def compute_async():\n    a = yield await parse_int_async(\"100\")\n    b = yield await parse_int_async(\"23\")\n    return a + b\n\nasync def main():\n    result = await compute_async()\n    if result.is_ok():\n        print(\"Async sum:\", result.unwrap())\n    else:\n        print(\"Async error:\", result.unwrap_err())\n\nasyncio.run(main())  # Async sum: 123\n</code></pre>"},{"location":"quickstart/#mapping-and-error-transformation","title":"Mapping and Error Transformation","text":"<pre><code>result = parse_int(\"not a number\").map(lambda x: x * 2).map_err(str)\nprint(result)  # Err('invalid literal for int() with base 10: ...')\n</code></pre> <p>For more detailed examples and advanced usage, check out the Examples section.</p>"},{"location":"rustico/","title":"Rustico","text":""},{"location":"rustico/#module-rustico","title":"module <code>rustico</code>","text":""},{"location":"rustico/#global-variables","title":"Global Variables","text":"<ul> <li>OkErr</li> </ul>"},{"location":"rustico/#function-as_result","title":"function <code>as_result</code>","text":"<pre><code>as_result(\n    *exceptions: 'BE'\n) \u2192 Callable[[Callable[, T]], Callable[, Result[T, BE]]]\n</code></pre> <p>Decorator that converts a function to return Result, catching specified exceptions as Err. </p> <p>Use when you want to convert exception-based APIs to Result-based APIs. Essential for integrating with existing codebases. Avoid when functions already return Results. </p> <pre><code>@as_result(ValueError)\ndef parse_int(x: str) -&gt; int:\n     return int(x)\n\nparse_int(\"42\")  # Ok(42)\nparse_int(\"fail\")  # Err(ValueError(...))\n</code></pre> <p></p>"},{"location":"rustico/#function-as_async_result","title":"function <code>as_async_result</code>","text":"<pre><code>as_async_result(\n    *exceptions: 'type[BE]'\n) \u2192 Callable[[Callable[, Awaitable[T]]], Callable[, Awaitable[Result[T, BE]]]]\n</code></pre> <p>Decorator that converts an async function to return Result, catching specified exceptions as Err. </p> <p>Use when you want to convert async exception-based APIs to Result-based APIs. Essential for integrating async codebases. Avoid when async functions already return Results. </p> <pre><code>@as_async_result(ValueError)\nasync def parse_int_async(x: str) -&gt; int:\n     return int(x)\n</code></pre> <p></p>"},{"location":"rustico/#function-is_ok","title":"function <code>is_ok</code>","text":"<pre><code>is_ok(result: 'Result[T, E]') \u2192 TypeIs[Ok[T]]\n</code></pre> <p>Type guard that returns True if the result is Ok, providing type narrowing. </p> <p>Use for type-safe conditional logic and when you need type narrowing. Essential for type checkers. Prefer result.is_ok() for simple boolean checks. </p> <pre><code>is_ok(Ok(1))  # True\nis_ok(Err(\"fail\"))  # False\n</code></pre> <p></p>"},{"location":"rustico/#function-is_err","title":"function <code>is_err</code>","text":"<pre><code>is_err(result: 'Result[T, E]') \u2192 TypeIs[Err[E]]\n</code></pre> <p>Type guard that returns True if the result is Err, providing type narrowing. </p> <p>Use for type-safe conditional logic and when you need type narrowing. Essential for type checkers. Prefer result.is_err() for simple boolean checks. </p> <pre><code>is_err(Ok(1))  # False\nis_err(Err(\"fail\"))  # True\n</code></pre> <p></p>"},{"location":"rustico/#function-match","title":"function <code>match</code>","text":"<pre><code>match(\n    result: 'Result[T, E]',\n    ok_handler: 'Callable[[T], T]',\n    err_handler: 'Callable[[E], T] | None' = None\n) \u2192 T | None\n</code></pre> <p>Pattern match on a Result and apply the appropriate handler function. </p> <p>This function provides a functional, explicit alternative to Python's pattern matching syntax, allowing you to handle both success (<code>Ok</code>) and error (<code>Err</code>) cases with dedicated handler functions. It's especially useful when you want to transform or branch on the contents of a Result without unwrapping it or writing conditional logic. </p> <p>When to use:  - When you want to handle both success and error cases in a single, readable expression.  - When you want to transform a Result into another value or type, e.g., for logging, formatting, or fallback logic.  - When you want to avoid <code>try/except</code> and keep error handling explicit and composable. </p> <p>When not to use:  - When you only care about the success value and want to fail fast (use <code>unwrap</code> or <code>unwrap_or</code>).  - When you only want to transform the success or error value (use <code>map</code> or <code>map_err</code>).  - When you need to propagate the Result further without handling it yet. </p> <pre><code>result = get_user_age()  # Returns Result[int, str]\nformatted = match(\n     result,\n     ok_handler=lambda age: f\"User is {age} years old\",\n     err_handler=lambda err: f\"Error getting age: {err}\"\n)\n# Ok case: \"User is 25 years old\"\n# Err case: \"Error getting age: Invalid user data\"\n</code></pre> <p></p>"},{"location":"rustico/#function-do","title":"function <code>do</code>","text":"<pre><code>do(\n    fn_or_gen: 'Callable[, Generator[Result[T, E], T | None, T]] | Generator[Result[T, E], T | None, T]'\n) \u2192 Callable[[], Result[T, E]] | Result[T, E]\n</code></pre> <p>Dual-purpose function for emulating do-notation with Result types. </p> <p>Use as a decorator for functions that yield Results, or as a helper for generators. Essential for imperative-style Result handling. Avoid when simple chaining suffices. Can be used as a decorator or called directly with a generator instance. </p> <pre><code>@do\ndef my_func() -&gt; Generator[...]:\n     x = yield Ok(2)\n     y = yield Ok(3)\n     return x + y\n\nmy_func()  # Ok(5)\n</code></pre> <p></p>"},{"location":"rustico/#function-do_async","title":"function <code>do_async</code>","text":"<pre><code>do_async(\n    fn_or_gen: 'Callable[, AsyncGenerator[Result[T, E], None]] | AsyncGenerator[Result[T, E], None]'\n) \u2192 Callable[, Awaitable[Result[T, E]]] | Awaitable[Result[T, E]]\n</code></pre> <p>Dual-purpose function for emulating async do-notation with Result types. </p> <p>Use as a decorator for async functions that yield Results, or as a helper for async generators. Essential for imperative-style async Result handling. Avoid when simple async chaining suffices. Can be used as a decorator or called directly with an async generator instance. </p> <pre><code>@do_async\nasync def my_func() -&gt; AsyncGenerator[...]:\n     x = yield Ok(2)\n     y = yield Ok(3)\n     return x + y\n</code></pre> <p></p>"},{"location":"rustico/#function-catch","title":"function <code>catch</code>","text":"<pre><code>catch(\n    *exceptions: 'type[BE]'\n) \u2192 Callable[[Callable[, T]], Callable[, Result[T, BE]]]\n</code></pre> <p>Decorator that catches specified exceptions and returns them as Err Results. </p> <p>Use when you want to convert specific exceptions to Results without catching all exceptions. More precise than as_result for targeted exception handling. Avoid when you need to catch all exceptions. </p> <pre><code>@catch(ValueError)\ndef parse(x: str) -&gt; int:\n     return int(x)\n</code></pre> <p></p>"},{"location":"rustico/#function-catch_async","title":"function <code>catch_async</code>","text":"<pre><code>catch_async(\n    *exceptions: 'type[BE]'\n) \u2192 Callable[[Callable[, Awaitable[T]]], Callable[, Awaitable[Result[T, BE]]]]\n</code></pre> <p>Decorator that catches specified exceptions in async functions and returns them as Err Results. </p> <p>Use when you want to convert specific async exceptions to Results without catching all exceptions. More precise than as_async_result for targeted exception handling. Avoid when you need to catch all exceptions. </p> <pre><code>@catch_async(ValueError)\nasync def parse_async(x: str) -&gt; int:\n     return int(x)\n</code></pre> <p></p>"},{"location":"rustico/#class-unwraperror","title":"class <code>UnwrapError</code>","text":"<p>Exception raised when an unwrap or expect operation fails on a Result. </p> <pre><code>try:\n     Err(\"fail\").unwrap()\nexcept UnwrapError as e:\n     print(e)\n# Called `Result.unwrap()` on an `Err` value: 'fail'\n</code></pre> <p></p>"},{"location":"rustico/#method-__init__","title":"method <code>__init__</code>","text":"<pre><code>__init__(result: 'Result[T, E]', message: 'str') \u2192 None\n</code></pre>"},{"location":"rustico/#property-result","title":"property result","text":"<p>Returns the original result that caused the unwrap failure. </p> <p>Useful for debugging and error recovery scenarios where you need to inspect the original Result that failed to unwrap. Common in error handling pipelines where you want to log the original error context. </p> <pre><code>try:\n     Err(\"fail\").unwrap()\nexcept UnwrapError as e:\n     assert isinstance(e.result, Err)\n</code></pre> <p></p>"},{"location":"rustico/#class-ok","title":"class <code>Ok</code>","text":"<p>Represents a successful result containing a value. </p> <p>Use when operations succeed and you want to chain further operations. Avoid when you need to represent failure states - use Err instead. </p> <pre><code>Ok(42).unwrap()  # 42\n</code></pre> <p></p>"},{"location":"rustico/#method-__init___1","title":"method <code>__init__</code>","text":"<pre><code>__init__(value: 'T') \u2192 None\n</code></pre>"},{"location":"rustico/#property-ok_value","title":"property ok_value","text":"<p>Returns the inner value for pattern matching and direct access. </p> <p>Use with match statements and when you need direct property access. Prefer unwrap() for general value extraction. Avoid when error handling is needed. </p> <pre><code>Ok(2).ok_value  # 2\n</code></pre> <p></p>"},{"location":"rustico/#method-alt","title":"method <code>alt</code>","text":"<pre><code>alt(op: 'Callable[[E], F]') \u2192 Ok[T]\n</code></pre> <p>No-op for Ok instances - error transformation doesn't apply to successful results. </p> <p>Use in generic code that handles both Ok and Err. The operation is ignored for Ok instances, maintaining the original value. Avoid when you know the Result is Ok. </p> <pre><code>Ok(1).alt(lambda e: 0)  # Ok(1)\n</code></pre> <p></p>"},{"location":"rustico/#method-and_then","title":"method <code>and_then</code>","text":"<pre><code>and_then(op: 'Callable[[T], Result[U, E]]') \u2192 Result[U, E]\n</code></pre> <p>Chains another Result-returning operation on the contained value (monadic bind). </p> <p>Use for chaining operations that can fail, creating pipelines of fallible computations. Essential for functional error handling. Avoid when the operation cannot fail. </p> <pre><code>Ok(2).and_then(lambda x: Ok(x * 2))  # Ok(4)\n</code></pre> <p></p>"},{"location":"rustico/#method-and_then_async","title":"method <code>and_then_async</code>","text":"<pre><code>and_then_async(op: 'Callable[[T], Awaitable[Result[U, E]]]') \u2192 Result[U, E]\n</code></pre> <p>Asynchronously chains another Result-returning operation on the contained value. </p> <p>Use for chaining async operations that can fail. Essential for async functional error handling patterns. Avoid when the async operation cannot fail. </p> <pre><code>await Ok(2).and_then_async(async_lambda)\n</code></pre> <p></p>"},{"location":"rustico/#method-err","title":"method <code>err</code>","text":"<pre><code>err() \u2192 None\n</code></pre> <p>Always returns None for Ok instances since there's no error. </p> <p>Use for symmetry with Err.err() in generic code. Avoid when you know the Result is Ok - the return will always be None. </p> <pre><code>Ok(1).err()  # None\n</code></pre> <p></p>"},{"location":"rustico/#method-expect","title":"method <code>expect</code>","text":"<pre><code>expect(_message: 'str') \u2192 T\n</code></pre> <p>Returns the contained value, ignoring the message since Ok cannot fail. </p> <p>Use when you want consistent API with Err.expect() in generic code. Prefer unwrap() when you know the Result is Ok. Avoid when error context isn't needed. </p> <pre><code>Ok(1).expect(\"should not fail\")  # 1\n</code></pre> <p></p>"},{"location":"rustico/#method-expect_err","title":"method <code>expect_err</code>","text":"<pre><code>expect_err(message: 'str') \u2192 NoReturn\n</code></pre> <p>Always raises UnwrapError since Ok instances don't contain errors. </p> <p>Use when you expect an error but got success - indicates a logic error. Common in testing scenarios. Avoid in normal business logic. </p> <pre><code>try:\n     Ok(1).expect_err(\"should be error\")\nexcept UnwrapError:\n     pass\n</code></pre> <p></p>"},{"location":"rustico/#method-inspect","title":"method <code>inspect</code>","text":"<pre><code>inspect(op: 'Callable[[T], Any]') \u2192 Result[T, E]\n</code></pre> <p>Calls the provided function with the contained value for side effects, returns self. </p> <p>Use for debugging, logging, or other side effects without changing the Result. Common for tracing successful values in pipelines. Avoid when side effects are expensive. </p> <pre><code>Ok(2).inspect(print)  # prints 2, returns Ok(2)\n</code></pre> <p></p>"},{"location":"rustico/#method-inspect_err","title":"method <code>inspect_err</code>","text":"<pre><code>inspect_err(op: 'Callable[[E], Any]') \u2192 Result[T, E]\n</code></pre> <p>No-op for Ok instances - error inspection doesn't apply to successful results. </p> <p>Use in generic code that handles both Ok and Err. The operation is ignored for Ok instances. Avoid when you know the Result is Ok. </p> <pre><code>Ok(2).inspect_err(print)  # Ok(2), nothing printed\n</code></pre> <p></p>"},{"location":"rustico/#method-is_err","title":"method <code>is_err</code>","text":"<pre><code>is_err() \u2192 Literal[False]\n</code></pre> <p>Always returns False for Ok instances. </p> <p>Use for type narrowing and conditional logic. Prefer this over isinstance checks for better type inference. Avoid when you already know the Result type. </p> <pre><code>Ok(1).is_err()  # False\n</code></pre> <p></p>"},{"location":"rustico/#method-is_ok","title":"method <code>is_ok</code>","text":"<pre><code>is_ok() \u2192 Literal[True]\n</code></pre> <p>Always returns True for Ok instances. </p> <p>Use for type narrowing and conditional logic. Prefer this over isinstance checks for better type inference. Avoid when you already know the Result type. </p> <pre><code>Ok(1).is_ok()  # True\n</code></pre> <p></p>"},{"location":"rustico/#method-map","title":"method <code>map</code>","text":"<pre><code>map(op: 'Callable[[T], U]') \u2192 Ok[U]\n</code></pre> <p>Transforms the contained value using the provided function, wrapping result in Ok. </p> <p>Use for transforming successful values while preserving the Ok context. Essential for functional programming patterns. Avoid when transformation can fail without proper error handling. </p> <pre><code>Ok(2).map(lambda x: x * 10)  # Ok(20)\n</code></pre> <p></p>"},{"location":"rustico/#method-map_async","title":"method <code>map_async</code>","text":"<pre><code>map_async(op: 'Callable[[T], Awaitable[U]]') \u2192 Ok[U]\n</code></pre> <p>Asynchronously transforms the contained value, wrapping result in Ok. </p> <p>Use for async transformations of successful values. Essential for async functional programming patterns. Avoid when the async operation can fail without proper error handling. </p> <pre><code>await Ok(2).map_async(async_lambda)\n</code></pre> <p></p>"},{"location":"rustico/#method-map_err","title":"method <code>map_err</code>","text":"<pre><code>map_err(op: 'Callable[[E], F]') \u2192 Ok[T]\n</code></pre> <p>No-op for Ok instances - error transformation doesn't apply to successful results. </p> <p>Use in generic code that handles both Ok and Err. The operation is ignored for Ok instances, maintaining the original value. Avoid when you know the Result is Ok. </p> <pre><code>Ok(2).map_err(lambda e: 0)  # Ok(2)\n</code></pre> <p></p>"},{"location":"rustico/#method-map_or","title":"method <code>map_or</code>","text":"<pre><code>map_or(default: 'U', op: 'Callable[[T], U]') \u2192 U\n</code></pre> <p>Transforms the contained value using the operation, ignoring the default. </p> <p>Use when you want consistent API with Err.map_or() in generic code. The default is never used for Ok instances. Prefer map() when you know the Result is Ok. </p> <pre><code>Ok(2).map_or(0, lambda x: x * 2)  # 4\n</code></pre> <p></p>"},{"location":"rustico/#method-map_or_else","title":"method <code>map_or_else</code>","text":"<pre><code>map_or_else(default_op: 'Callable[[], U]', op: 'Callable[[T], U]') \u2192 U\n</code></pre> <p>Transforms the contained value using the operation, ignoring the default operation. </p> <p>Use when you want consistent API with Err.map_or_else() in generic code. The default operation is never called for Ok instances. Prefer map() when you know the Result is Ok. </p> <pre><code>Ok(2).map_or_else(lambda: 0, lambda x: x * 2)  # 4\n</code></pre> <p></p>"},{"location":"rustico/#method-match","title":"method <code>match</code>","text":"<pre><code>match(\n    ok: 'Callable[[T], U] | None' = None,\n    err: 'Callable[[E], U] | None' = None\n) \u2192 U\n</code></pre> <p>Pattern matches on Ok, requiring an 'ok' handler and ignoring 'err' handler. </p> <p>Use for exhaustive pattern matching with clear intent. Provides type safety and forces explicit handling. Avoid when simple unwrap() or map() suffices. </p> <pre><code>Ok(1).match(ok=lambda x: f\"Got {x}\", err=lambda e: f\"Error: {e}\")  # 'Got 1'\n</code></pre> <p></p>"},{"location":"rustico/#method-ok","title":"method <code>ok</code>","text":"<pre><code>ok() \u2192 T\n</code></pre> <p>Returns the contained value for Ok instances. </p> <p>Use when you want to extract the value without unwrapping. Prefer unwrap() when you're certain the Result is Ok. Avoid when you need error handling. </p> <pre><code>Ok(1).ok()  # 1\n</code></pre> <p></p>"},{"location":"rustico/#method-or_else","title":"method <code>or_else</code>","text":"<pre><code>or_else(op: 'Callable[[E], Result[T, F]]') \u2192 Ok[T]\n</code></pre> <p>No-op for Ok instances - error recovery doesn't apply to successful results. </p> <p>Use in generic code that handles both Ok and Err. The operation is ignored for Ok instances, maintaining the original value. Avoid when you know the Result is Ok. </p> <pre><code>Ok(2).or_else(lambda e: Ok(0))  # Ok(2)\n</code></pre> <p></p>"},{"location":"rustico/#method-unwrap","title":"method <code>unwrap</code>","text":"<pre><code>unwrap() \u2192 T\n</code></pre> <p>Returns the contained value safely since Ok instances always contain values. </p> <p>Use when you're certain the Result is Ok or when you want to fail fast on errors. Prefer this over ok() for value extraction. Avoid when error handling is required. </p> <pre><code>Ok(1).unwrap()  # 1\n</code></pre> <p></p>"},{"location":"rustico/#method-unwrap_err","title":"method <code>unwrap_err</code>","text":"<pre><code>unwrap_err() \u2192 NoReturn\n</code></pre> <p>Always raises UnwrapError since Ok instances don't contain errors. </p> <p>Use when you expect an error but got success - indicates a logic error. Common in testing scenarios. Avoid in normal business logic. </p> <pre><code>try:\n     Ok(1).unwrap_err()\nexcept UnwrapError:\n     pass\n</code></pre> <p></p>"},{"location":"rustico/#method-unwrap_or","title":"method <code>unwrap_or</code>","text":"<pre><code>unwrap_or(_default: 'U') \u2192 T\n</code></pre> <p>Returns the contained value, ignoring the default since Ok always has a value. </p> <p>Use when you want consistent API with Err.unwrap_or() in generic code. Prefer unwrap() when you know the Result is Ok. Avoid when the default is expensive. </p> <pre><code>Ok(1).unwrap_or(0)  # 1\n</code></pre> <p></p>"},{"location":"rustico/#method-unwrap_or_else","title":"method <code>unwrap_or_else</code>","text":"<pre><code>unwrap_or_else(op: 'Callable[[E], T]') \u2192 T\n</code></pre> <p>Returns the contained value, ignoring the operation since Ok always has a value. </p> <p>Use when you want consistent API with Err.unwrap_or_else() in generic code. The operation is never called for Ok instances. Avoid when you know the Result is Ok. </p> <pre><code>Ok(1).unwrap_or_else(lambda e: 0)  # 1\n</code></pre> <p></p>"},{"location":"rustico/#method-unwrap_or_raise","title":"method <code>unwrap_or_raise</code>","text":"<pre><code>unwrap_or_raise(e: 'E') \u2192 T\n</code></pre> <p>Returns the contained value, ignoring the exception since Ok cannot fail. </p> <p>Use when you want consistent API with Err.unwrap_or_raise() in generic code. The exception is never raised for Ok instances. Avoid when you know the Result is Ok. </p> <pre><code>Ok(1).unwrap_or_raise(Exception)  # 1\n</code></pre> <p></p>"},{"location":"rustico/#method-value_or","title":"method <code>value_or</code>","text":"<pre><code>value_or(default: 'Any') \u2192 T\n</code></pre> <p>Returns the contained value, ignoring the default (alias for unwrap_or). </p> <p>Use when you want consistent API with Err.value_or(). Prefer unwrap() when you know the Result is Ok. Avoid when the default value is expensive to compute. </p> <pre><code>Ok(42).value_or(0)  # 42\n</code></pre> <p></p>"},{"location":"rustico/#class-err","title":"class <code>Err</code>","text":"<p>Represents a failed result containing an error value. </p> <p>Use when operations fail and you want to propagate error information. Avoid when success is the only meaningful outcome. </p> <pre><code>Err(\"fail\").unwrap_or(0)  # 0\n</code></pre> <p></p>"},{"location":"rustico/#method-__init___2","title":"method <code>__init__</code>","text":"<pre><code>__init__(value: 'E') \u2192 None\n</code></pre>"},{"location":"rustico/#property-err_value","title":"property err_value","text":"<p>Returns the inner error value for pattern matching and direct access. </p> <p>Use with match statements and when you need direct property access. Prefer unwrap_err() for general error extraction. Avoid when success handling is needed. </p> <pre><code>Err(\"fail\").err_value  # \"fail\"\n</code></pre>"},{"location":"rustico/#property-trace","title":"property trace","text":"<p>Returns the captured stack trace as a list of formatted strings for BaseException errors. </p> <p>Use for debugging and error reporting when the error value is an exception. Computed lazily to avoid performance overhead. Returns None for non-exception errors. Avoid when error value is not an exception. </p> <p>try:  raise ValueError(\"fail\") except ValueError as e:  err = Err(e)  print(err.trace) </p> <p></p>"},{"location":"rustico/#method-alt_1","title":"method <code>alt</code>","text":"<pre><code>alt(op: 'Callable[[E], F]') \u2192 Err[F]\n</code></pre> <p>Transforms the contained error value using the provided function, wrapping result in Err. </p> <p>Use for transforming error values while preserving the Err context. Common for error normalization and enrichment. Avoid when error transformation can fail without proper handling. </p> <pre><code>Err(1).alt(lambda e: e + 1)  # Err(2)\n</code></pre> <p></p>"},{"location":"rustico/#method-and_then_1","title":"method <code>and_then</code>","text":"<pre><code>and_then(op: 'Callable[[T], Result[U, E]]') \u2192 Err[E]\n</code></pre> <p>No-op for Err instances - chaining operations doesn't apply to failed results. </p> <p>Use in generic code that handles both Ok and Err. The operation is ignored for Err instances, maintaining the original error. Avoid when you know the Result is Err. </p> <pre><code>Err(\"fail\").and_then(lambda x: Ok(x * 2))  # Err('fail')\n</code></pre> <p></p>"},{"location":"rustico/#method-and_then_async_1","title":"method <code>and_then_async</code>","text":"<pre><code>and_then_async(op: 'Callable[[T], Awaitable[Result[U, E]]]') \u2192 Err[E]\n</code></pre> <p>No-op for Err instances - async chaining operations doesn't apply to failed results. </p> <p>Use in generic code that handles both Ok and Err. The operation is ignored for Err instances, maintaining the original error. Avoid when you know the Result is Err. </p> <pre><code>await Err(\"fail\").and_then_async(lambda x: Ok(x * 2))  # Err('fail')\n</code></pre> <p></p>"},{"location":"rustico/#method-err_1","title":"method <code>err</code>","text":"<pre><code>err() \u2192 E\n</code></pre> <p>Returns the contained error value for Err instances. </p> <p>Use when you want to extract the error without unwrapping. Prefer unwrap_err() when you're certain the Result is Err. Avoid when you need success handling. </p> <pre><code>Err(\"fail\").err()  # \"fail\"\n</code></pre> <p></p>"},{"location":"rustico/#method-expect_1","title":"method <code>expect</code>","text":"<pre><code>expect(message: 'str') \u2192 NoReturn\n</code></pre> <p>Always raises UnwrapError with the provided message since Err instances represent failure. </p> <p>Use when you expect success but got failure - provides clear error context. Common for assertions and fail-fast scenarios. Avoid in normal error handling. </p> <pre><code>try:\n     Err(\"fail\").expect(\"should not fail\")\nexcept UnwrapError:\n     pass\n</code></pre> <p></p>"},{"location":"rustico/#method-expect_err_1","title":"method <code>expect_err</code>","text":"<pre><code>expect_err(_message: 'str') \u2192 E\n</code></pre> <p>Returns the contained error value, ignoring the message since Err always contains errors. </p> <p>Use when you want consistent API with Ok.expect_err() in generic code. Prefer unwrap_err() when you know the Result is Err. Avoid when success context isn't needed. </p> <pre><code>Err(\"fail\").expect_err(\"should be error\")  # \"fail\"\n</code></pre> <p></p>"},{"location":"rustico/#method-inspect_1","title":"method <code>inspect</code>","text":"<pre><code>inspect(op: 'Callable[[T], Any]') \u2192 Result[T, E]\n</code></pre> <p>No-op for Err instances - value inspection doesn't apply to failed results. </p> <p>Use in generic code that handles both Ok and Err. The operation is ignored for Err instances. Avoid when you know the Result is Err. </p> <pre><code>Err(\"fail\").inspect(print)  # Err('fail'), nothing printed\n</code></pre> <p></p>"},{"location":"rustico/#method-inspect_err_1","title":"method <code>inspect_err</code>","text":"<pre><code>inspect_err(op: 'Callable[[E], Any]') \u2192 Result[T, E]\n</code></pre> <p>Calls the provided function with the contained error value for side effects, returns self. </p> <p>Use for debugging, logging, or other side effects without changing the Result. Common for tracing error values in pipelines. Avoid when side effects are expensive. </p> <pre><code>Err(\"fail\").inspect_err(print)  # prints 'fail', returns Err('fail')\n</code></pre> <p></p>"},{"location":"rustico/#method-is_err_1","title":"method <code>is_err</code>","text":"<pre><code>is_err() \u2192 Literal[True]\n</code></pre> <p>Always returns True for Err instances. </p> <p>Use for type narrowing and conditional logic. Prefer this over isinstance checks for better type inference. Avoid when you already know the Result type. </p> <pre><code>Err(\"fail\").is_err()  # True\n</code></pre> <p></p>"},{"location":"rustico/#method-is_ok_1","title":"method <code>is_ok</code>","text":"<pre><code>is_ok() \u2192 Literal[False]\n</code></pre> <p>Always returns False for Err instances. </p> <p>Use for type narrowing and conditional logic. Prefer this over isinstance checks for better type inference. Avoid when you already know the Result type. </p> <pre><code>Err(\"fail\").is_ok()  # False\n</code></pre> <p></p>"},{"location":"rustico/#method-map_1","title":"method <code>map</code>","text":"<pre><code>map(op: 'Callable[[T], U]') \u2192 Err[E]\n</code></pre> <p>No-op for Err instances - value transformation doesn't apply to failed results. </p> <p>Use in generic code that handles both Ok and Err. The operation is ignored for Err instances, maintaining the original error. Avoid when you know the Result is Err. </p> <pre><code>Err(\"fail\").map(lambda x: x * 2)  # Err('fail')\n</code></pre> <p></p>"},{"location":"rustico/#method-map_async_1","title":"method <code>map_async</code>","text":"<pre><code>map_async(op: 'Callable[[T], Awaitable[U]]') \u2192 Err[E]\n</code></pre> <p>No-op for Err instances - async value transformation doesn't apply to failed results. </p> <p>Use in generic code that handles both Ok and Err. The operation is ignored for Err instances, maintaining the original error. Avoid when you know the Result is Err. </p> <pre><code>await Err(\"fail\").map_async(lambda x: x * 2)  # Err('fail')\n</code></pre> <p></p>"},{"location":"rustico/#method-map_err_1","title":"method <code>map_err</code>","text":"<pre><code>map_err(op: 'Callable[[E], F]') \u2192 Err[F]\n</code></pre> <p>Transforms the contained error value using the provided function, wrapping result in Err. </p> <p>Use for transforming error values while preserving the Err context. Common for error normalization and enrichment. Avoid when error transformation can fail. </p> <pre><code>Err(2).map_err(lambda e: e + 1)  # Err(3)\n</code></pre> <p></p>"},{"location":"rustico/#method-map_or_1","title":"method <code>map_or</code>","text":"<pre><code>map_or(default: 'U', op: 'Callable[[T], U]') \u2192 U\n</code></pre> <p>Returns the default value since Err instances don't contain success values to transform. </p> <p>Use when you want to provide a fallback value instead of transforming. The operation is ignored for Err instances. Avoid when the default is expensive. </p> <pre><code>Err(\"fail\").map_or(0, lambda x: x * 2)  # 0\n</code></pre> <p></p>"},{"location":"rustico/#method-map_or_else_1","title":"method <code>map_or_else</code>","text":"<pre><code>map_or_else(default_op: 'Callable[[], U]', op: 'Callable[[E], U]') \u2192 U\n</code></pre> <p>Calls the default operation since Err instances don't contain success values to transform. </p> <p>Use when you want to compute a fallback value for failed results. The main operation is ignored for Err instances. Avoid when the default operation is expensive. </p> <pre><code>Err(\"fail\").map_or_else(lambda: 42, lambda x: x * 2)  # 42\n</code></pre> <p></p>"},{"location":"rustico/#method-match_1","title":"method <code>match</code>","text":"<pre><code>match(\n    ok: 'Callable[[T], U] | None' = None,\n    err: 'Callable[[E], U] | None' = None\n) \u2192 U\n</code></pre> <p>Pattern matches on Err, requiring an 'err' handler and ignoring 'ok' handler. </p> <p>Use for exhaustive pattern matching with clear intent. Provides type safety and forces explicit handling. Avoid when simple unwrap_err() or map_err() suffices. </p> <pre><code>Err(\"fail\").match(ok=lambda x: f\"Got {x}\", err=lambda e: f\"Error: {e}\")  # 'Error: fail'\n</code></pre> <p></p>"},{"location":"rustico/#method-ok_1","title":"method <code>ok</code>","text":"<pre><code>ok() \u2192 None\n</code></pre> <p>Always returns None for Err instances since there's no success value. </p> <p>Use for symmetry with Ok.ok() in generic code. Avoid when you know the Result is Err - the return will always be None. </p> <pre><code>Err(\"fail\").ok()  # None\n</code></pre> <p></p>"},{"location":"rustico/#method-or_else_1","title":"method <code>or_else</code>","text":"<pre><code>or_else(op: 'Callable[[E], Result[T, E]]') \u2192 Result[T, E]\n</code></pre> <p>Applies error recovery operation to the contained error value (monadic bind for errors). </p> <p>Use for chaining error recovery operations, creating pipelines of error handling. Essential for functional error recovery patterns. Avoid when the operation cannot fail. </p> <pre><code>Err(2).or_else(lambda e: Ok(e + 1))  # Ok(3)\n</code></pre> <p></p>"},{"location":"rustico/#method-unwrap_1","title":"method <code>unwrap</code>","text":"<pre><code>unwrap() \u2192 NoReturn\n</code></pre> <p>Always raises UnwrapError since Err instances don't contain success values. </p> <p>Use when you expect success but got failure - indicates a logic error. Common for fail-fast scenarios and debugging. Avoid in normal error handling. </p> <p>The <code>unwrap()</code> method is powerful but should be used with caution. It's designed for situations where you are certain the <code>Result</code> holds a successful value (<code>Ok</code>). </p> <ul> <li>If you call <code>result.unwrap()</code> on an <code>Ok</code> instance, it safely returns the contained value. *   However, if you call <code>result.unwrap()</code> on an <code>Err</code> instance, it will raise an <code>UnwrapError</code> exception. This is a \"fail-fast\" mechanism, indicating an unexpected error or a logical flaw in your code. </li> </ul> <p>For robust error handling where you expect and want to gracefully manage potential errors, prefer using methods like <code>is_ok()</code>, <code>is_err()</code>, <code>unwrap_or()</code>, <code>unwrap_or_else()</code>, <code>and_then()</code>, or Python's <code>match</code> statement to process the <code>Result</code> without risking an exception. </p> <pre><code>try:\n     Err(\"fail\").unwrap()\nexcept UnwrapError:\n     pass\n</code></pre> <p></p>"},{"location":"rustico/#method-unwrap_err_1","title":"method <code>unwrap_err</code>","text":"<pre><code>unwrap_err() \u2192 E\n</code></pre> <p>Returns the contained error value safely since Err instances always contain errors. </p> <p>Use when you're certain the Result is Err or when you want to fail fast on success. Prefer this over err() for error extraction. Avoid when success handling is required. </p> <pre><code>Err(\"fail\").unwrap_err()  # \"fail\"\n</code></pre> <p></p>"},{"location":"rustico/#method-unwrap_or_1","title":"method <code>unwrap_or</code>","text":"<pre><code>unwrap_or(default: 'U') \u2192 U\n</code></pre> <p>Returns the default value since Err instances don't contain success values. </p> <p>Use when you want to provide a fallback value for failed operations. Essential for graceful degradation patterns. Avoid when the default is expensive to compute. </p> <pre><code>Err(\"fail\").unwrap_or(0)  # 0\n</code></pre> <p></p>"},{"location":"rustico/#method-unwrap_or_else_1","title":"method <code>unwrap_or_else</code>","text":"<pre><code>unwrap_or_else(op: 'Callable[[E], T]') \u2192 T\n</code></pre> <p>Applies the operation to the error value and returns the result. </p> <p>Use when you want to compute a fallback value based on the error. Essential for error recovery patterns. Avoid when the operation is expensive or can fail. </p> <pre><code>Err(2).unwrap_or_else(lambda e: e + 1)  # 3\n</code></pre> <p></p>"},{"location":"rustico/#method-unwrap_or_raise_1","title":"method <code>unwrap_or_raise</code>","text":"<pre><code>unwrap_or_raise(e: 'E') \u2192 NoReturn\n</code></pre> <p>Raises the provided exception type with the error value as the message. </p> <p>Use when you want to convert Result errors to traditional exceptions. Common at API boundaries. Avoid when you want to maintain Result-based error handling. </p> <pre><code>try:\n     Err(\"fail\").unwrap_or_raise(ValueError)\nexcept ValueError:\n     pass\n</code></pre> <p></p>"},{"location":"rustico/#method-value_or_1","title":"method <code>value_or</code>","text":"<pre><code>value_or(default: 'U') \u2192 U\n</code></pre> <p>Returns the default value since Err instances don't contain success values. </p> <p>Use when you want to provide a fallback value for failed operations. Essential for graceful degradation patterns. Avoid when the default is expensive to compute. </p> <pre><code>Err(\"fail\").value_or(0)  # 0\n</code></pre> <p>This file was automatically generated via lazydocs.</p>"}]}