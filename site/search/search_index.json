{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"rustico","text":"<p>A Schr\u00f6dinger's Cat for Python error handling: your result is both alive and dead\u2014until you unwrap it.</p>"},{"location":"#what-is-rustico","title":"What is <code>rustico</code>?","text":"<p><code>rustico</code> brings the power and elegance of Rust's <code>Result</code> type to Python. Every operation is either a success (<code>Ok</code>) or a failure (<code>Err</code>), and you must explicitly handle both. No more try/except hell\u2014just beautiful, predictable, and composable error handling.</p>"},{"location":"#schrodingers-cat-the-metaphor","title":"Schr\u00f6dinger's Cat: The Metaphor","text":"<p>Imagine every function call as a box containing Schr\u00f6dinger's cat. Until you open (unwrap) the box, the cat is both alive (<code>Ok</code>) and dead (<code>Err</code>). With <code>rustico</code>, you don't have to guess or hope\u2014when you unwrap the result, you'll know exactly what you got, and you'll handle both cases explicitly.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\udd12 Can't Forget Error Handling: The type system forces you to handle both cases</li> <li>\ud83d\udccd Precise Error Information: Know exactly what and where things failed</li> <li>\ud83e\udde9 Composable: Chain operations without nested try/except blocks</li> <li>\ud83c\udfaf Early Exit: Stop processing on first error automatically</li> <li>\ud83d\udd0d Type Safe: Your IDE knows about both success and error cases</li> <li>\u26a1 Async Support: First-class support for async/await</li> <li>\ud83e\uddea Test Friendly: Easily mock and test error conditions</li> <li>\ud83d\udd04 Pattern Matching: Native support for Python 3.10+ pattern matching</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation</li> <li>Quick Start</li> <li>API Reference</li> <li>Examples</li> <li>Comparison with Other Libraries</li> <li>Contributing</li> </ul>"},{"location":"comparison/","title":"Comparison with Other Libraries","text":"<p>This page compares <code>rustico</code> with other similar libraries in the Python ecosystem.</p>"},{"location":"comparison/#feature-comparison","title":"Feature Comparison","text":"Library Ok/Err do-notation Async Decorators Type Guards Tracebacks Type Hints Monads Rust-like Philosophy Size rustico \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 CUPID, explicit Small result \u2705 \u274c \u274c \u274c \u274c \u274c \u2705 Partial \u2705 Simplicity Tiny returns \u2705 Partial \u2705 \u2705 \u2705 \u274c \u2705 \u2705 Partial Functional Large poltergeist \u2705 \u274c \u274c \u274c \u274c \u274c \u2705 \u274c \u2705 Minimalism Tiny rusty-errors \u2705 \u274c \u274c \u274c \u274c \u274c \u2705 Partial \u2705 Rust-inspired Small <p>Legend:</p> <ul> <li>do-notation: Generator-based early-exit chaining</li> <li>Async: Native async/await support</li> <li>Decorators: Built-in function wrapping decorators</li> <li>Type Guards: <code>is_ok</code>, <code>is_err</code> for static analysis</li> <li>Tracebacks: Captures exception tracebacks in <code>Err</code></li> <li>Monads: Supports chaining, mapping, flatMap operations</li> <li>Rust-like: API and philosophy inspired by Rust</li> </ul>"},{"location":"comparison/#detailed-comparison","title":"Detailed Comparison","text":""},{"location":"comparison/#rustico-this-library","title":"rustico (This Library)","text":"<ul> <li>Strengths: Full-featured, async-first, excellent TypeScript-like developer experience</li> <li>Philosophy: CUPID principle - Composable, Unix-like, Predictable, Idiomatic, Declarative</li> <li>Best for: New projects, async workflows, teams wanting explicit error handling</li> <li>Unique features: Traceback capture, do-notation, dual-mode decorators</li> </ul>"},{"location":"comparison/#result","title":"result","text":"<ul> <li>Strengths: Simple, lightweight, battle-tested</li> <li>Philosophy: Keep it simple and close to Rust's API</li> <li>Best for: Simple sync applications, minimal dependencies</li> <li>Limitations: No async support, no decorators, basic feature set</li> </ul>"},{"location":"comparison/#returns","title":"returns","text":"<ul> <li>Strengths: Rich functional programming features, extensive ecosystem</li> <li>Philosophy: Bring functional programming concepts to Python</li> <li>Best for: FP enthusiasts, complex data transformation pipelines</li> <li>Unique features: Maybe, IO, containers, railway-oriented programming</li> <li>Limitations: Learning curve, heavy dependency</li> </ul>"},{"location":"comparison/#poltergeist","title":"poltergeist","text":"<ul> <li>Strengths: Extremely minimal, zero dependencies</li> <li>Philosophy: Minimalism above all</li> <li>Best for: Embedded systems, minimal footprint requirements</li> <li>Limitations: Very basic feature set, no advanced operations</li> </ul>"},{"location":"comparison/#rusty-errors","title":"rusty-errors","text":"<ul> <li>Strengths: Close to Rust's Result API</li> <li>Philosophy: Direct Rust port</li> <li>Best for: Rust developers transitioning to Python</li> <li>Limitations: Limited Python-specific features, no async</li> </ul>"},{"location":"comparison/#code-comparison","title":"Code Comparison","text":""},{"location":"comparison/#basic-usage","title":"Basic Usage","text":""},{"location":"comparison/#rustico","title":"rustico","text":"<pre><code>from rustico import Ok, Err, as_result\n\n@as_result(ValueError)\ndef parse_int(s: str) -&gt; int:\n    return int(s)\n\nresult = parse_int(\"123\")\nif result.is_ok():\n    print(result.unwrap())  # 123\nelse:\n    print(f\"Error: {result.unwrap_err()}\")\n</code></pre>"},{"location":"comparison/#result_1","title":"result","text":"<pre><code>from result import Ok, Err, Result\n\ndef parse_int(s: str) -&gt; Result[int, ValueError]:\n    try:\n        return Ok(int(s))\n    except ValueError as e:\n        return Err(e)\n\nresult = parse_int(\"123\")\nif result.is_ok():\n    print(result.unwrap())  # 123\nelse:\n    print(f\"Error: {result.unwrap_err()}\")\n</code></pre>"},{"location":"comparison/#returns_1","title":"returns","text":"<pre><code>from returns.result import Success, Failure, Result\nfrom returns.functions import raise_exception\n\ndef parse_int(s: str) -&gt; Result[int, ValueError]:\n    try:\n        return Success(int(s))\n    except ValueError as e:\n        return Failure(e)\n\nresult = parse_int(\"123\")\nresult.map(print)  # 123\nresult.alt(raise_exception)\n</code></pre>"},{"location":"comparison/#chaining-operations","title":"Chaining Operations","text":""},{"location":"comparison/#rustico_1","title":"rustico","text":"<pre><code>from rustico import Ok, Err, do\n\n@do\ndef process():\n    x = yield parse_int(\"10\")\n    y = yield parse_int(\"20\")\n    return x + y\n\nresult = process()\nprint(result)  # Ok(30)\n</code></pre>"},{"location":"comparison/#result_2","title":"result","text":"<pre><code>from result import Ok, Err\n\ndef process():\n    x_result = parse_int(\"10\")\n    if x_result.is_err():\n        return x_result\n\n    y_result = parse_int(\"20\")\n    if y_result.is_err():\n        return y_result\n\n    return Ok(x_result.unwrap() + y_result.unwrap())\n\nresult = process()\nprint(result)  # Ok(30)\n</code></pre>"},{"location":"comparison/#returns_2","title":"returns","text":"<pre><code>from returns.result import Success, Failure\nfrom returns.functions import raise_exception\n\ndef process():\n    return parse_int(\"10\").bind(\n        lambda x: parse_int(\"20\").map(\n            lambda y: x + y\n        )\n    )\n\nresult = process()\nprint(result)  # Success(30)\n</code></pre>"},{"location":"comparison/#why-choose-rustico","title":"Why Choose rustico?","text":"<ul> <li>Balanced Approach: Not too minimal, not too complex</li> <li>Async-First: Built with modern async Python in mind</li> <li>Developer Experience: Excellent type hints and IDE integration</li> <li>Explicit Error Handling: Makes error cases impossible to ignore</li> <li>Traceback Capture: Preserves stack traces for better debugging</li> <li>Pattern Matching: First-class support for Python 3.10+ pattern matching</li> <li>Composable: Easy to chain operations with do-notation</li> <li>Rust-Inspired: Familiar API for Rust developers</li> </ul> <p>Choose <code>rustico</code> if you want a modern, well-balanced Result type implementation that works well with both synchronous and asynchronous code, provides excellent developer experience, and makes error handling explicit and composable.</p>"},{"location":"contributing/","title":"Contributing to rustico","text":"<p>Thank you for your interest in contributing to <code>rustico</code>! This document provides guidelines and instructions for contributing to the project.</p>"},{"location":"contributing/#development-environment-setup","title":"Development Environment Setup","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork locally</li> <li>Set up the development environment:</li> </ol> <pre><code># Install PDM if you don't have it\npip install pdm\n\n# Install development dependencies\npdm install\n</code></pre>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":"<ol> <li>Create a new branch for your feature or bugfix:</li> </ol> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> <ol> <li>Make your changes and write tests for them</li> <li>Run the tests to ensure everything works:</li> </ol> <pre><code>pdm test\n</code></pre> <ol> <li>Format your code:</li> </ol> <pre><code>pdm format\n</code></pre> <ol> <li>Commit your changes with a descriptive commit message</li> <li>Push your branch to your fork</li> <li>Create a pull request to the main repository</li> </ol>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We follow PEP 8 guidelines with a few modifications. The project uses Ruff for linting and formatting.</p> <p>Key style points:</p> <ul> <li>Use type hints for all function parameters and return values</li> <li>Write docstrings for all public functions, classes, and methods</li> <li>Keep lines under 100 characters</li> <li>Use descriptive variable names</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<p>All new features should include tests. We use pytest for testing.</p> <ul> <li>Write unit tests for all new functionality</li> <li>Ensure all tests pass before submitting a pull request</li> <li>Aim for high test coverage</li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Documentation is crucial for <code>rustico</code>. When adding new features:</p> <ul> <li>Update docstrings with clear explanations and examples</li> <li>Add type hints that work well with static type checkers</li> <li>Consider adding examples to the documentation</li> </ul>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Ensure your code passes all tests</li> <li>Update the documentation if needed</li> <li>Add your changes to the CHANGELOG.md file</li> <li>Submit a pull request with a clear description of the changes</li> <li>Address any feedback from code reviews</li> </ol>"},{"location":"contributing/#release-process","title":"Release Process","text":"<p>Releases are managed by the maintainers. The general process is:</p> <ol> <li>Update version in pyproject.toml</li> <li>Update CHANGELOG.md</li> <li>Create a new release on GitHub</li> <li>Publish to PyPI</li> </ol>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please be respectful and considerate of others when contributing to the project. We aim to foster an inclusive and welcoming community.</p>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing to <code>rustico</code>, you agree that your contributions will be licensed under the project's MIT license.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page contains practical examples of using <code>rustico</code> in real-world scenarios.</p> <p>About these examples</p> <p>These examples demonstrate real-world use cases for <code>rustico</code>. They're designed to be copy-paste friendly and show best practices for error handling.</p> <p>Pro tip</p> <p>Most examples use the <code>@do</code> decorator for composing operations. This is the recommended approach for complex workflows.</p> <p>Get Started with Examples View on GitHub</p>"},{"location":"examples/#web-api-client","title":"Web API Client","text":"<p> Use Case: Making HTTP requests with proper error handling</p> <pre><code>import requests\nfrom rustico import as_result, do, Ok, Err, Result\n\n@as_result(requests.RequestException)\ndef fetch_user(user_id: int) -&gt; dict:\n    response = requests.get(f\"https://api.example.com/users/{user_id}\")\n    response.raise_for_status()\n    return response.json()\n\n@as_result(KeyError, TypeError)\ndef extract_email(user_data: dict) -&gt; str:\n    return user_data[\"email\"]\n\n@do\ndef get_user_email(user_id: int) -&gt; Result[str, Exception]:\n    user_data = yield fetch_user(user_id)\n    email = yield extract_email(user_data)\n    return email.lower()\n\n# Usage\nresult = get_user_email(123)\nmatch result:\n    case Ok(email):\n        print(f\"User email: {email}\")\n    case Err(error):\n        if isinstance(error, requests.ConnectionError):\n            print(\"Network error. Please check your connection.\")\n        elif isinstance(error, requests.HTTPError):\n            print(f\"API error: {error}\")\n        elif isinstance(error, KeyError):\n            print(\"User data is missing email field\")\n        else:\n            print(f\"Unexpected error: {error}\")\n</code></pre>"},{"location":"examples/#database-operations","title":"Database Operations","text":"<p> Use Case: Safe database interactions with automatic connection handling</p> <pre><code>import sqlite3\nfrom typing import List\nfrom rustico import as_result, do, Ok, Err, Result\n\n@as_result(sqlite3.Error)\ndef connect_db(db_path: str) -&gt; sqlite3.Connection:\n    return sqlite3.connect(db_path)\n\n@as_result(sqlite3.Error)\ndef execute_query(conn: sqlite3.Connection, query: str, params: tuple = ()) -&gt; List[tuple]:\n    cursor = conn.cursor()\n    cursor.execute(query, params)\n    return cursor.fetchall()\n\n@do\ndef get_user_posts(db_path: str, user_id: int) -&gt; Result[List[dict], Exception]:\n    conn = yield connect_db(db_path)\n\n    try:\n        rows = yield execute_query(\n            conn, \n            \"SELECT id, title, content FROM posts WHERE user_id = ?\", \n            (user_id,)\n        )\n\n        posts = [\n            {\"id\": row[0], \"title\": row[1], \"content\": row[2]}\n            for row in rows\n        ]\n\n        return posts\n    finally:\n        conn.close()\n\n# Usage\nresult = get_user_posts(\"app.db\", 42)\nif result.is_ok():\n    posts = result.unwrap()\n    print(f\"Found {len(posts)} posts\")\n    for post in posts:\n        print(f\"- {post['title']}\")\nelse:\n    print(f\"Database error: {result.unwrap_err()}\")\n</code></pre>"},{"location":"examples/#file-operations","title":"File Operations","text":"<p> Use Case: Reading and parsing configuration files safely</p> <pre><code>import json\nfrom pathlib import Path\nfrom rustico import as_result, do, Ok, Err, Result\n\n@as_result(FileNotFoundError, PermissionError)\ndef read_file(path: str) -&gt; str:\n    return Path(path).read_text(encoding=\"utf-8\")\n\n@as_result(json.JSONDecodeError)\ndef parse_json(content: str) -&gt; dict:\n    return json.loads(content)\n\n@do\ndef load_config(config_path: str) -&gt; Result[dict, Exception]:\n    content = yield read_file(config_path)\n    config = yield parse_json(content)\n\n    # Validate config\n    if \"api_key\" not in config:\n        return Err(ValueError(\"Missing required 'api_key' in config\"))\n\n    return config\n\n# Usage\nresult = load_config(\"config.json\")\nconfig = result.unwrap_or({\n    \"api_key\": \"default_key\",\n    \"timeout\": 30,\n    \"debug\": False\n})\n\nprint(f\"Using API key: {config['api_key']}\")\n</code></pre>"},{"location":"examples/#error-handling-patterns","title":"Error Handling Patterns","text":"<p>Common Pitfalls</p> <p>Remember that <code>unwrap()</code> will raise an exception if called on an <code>Err</code> result. Always check with <code>is_ok()</code> first or use <code>unwrap_or()</code> if you need a fallback value.</p>"},{"location":"examples/#fallback-values","title":"Fallback Values","text":"<pre><code>from rustico import as_result, Ok, Err\n\n@as_result(ValueError)\ndef parse_int(s: str) -&gt; int:\n    return int(s)\n\n# Using unwrap_or for fallback\nport = parse_int(os.environ.get(\"PORT\", \"\")).unwrap_or(8080)\nprint(f\"Starting server on port {port}\")\n</code></pre>"},{"location":"examples/#transforming-errors","title":"Transforming Errors","text":"<pre><code>from rustico import as_result, Ok, Err\n\n@as_result(ValueError)\ndef parse_int(s: str) -&gt; int:\n    return int(s)\n\n# Transform error to a user-friendly message\nresult = parse_int(\"abc\").map_err(lambda e: f\"Invalid number format: {e}\")\nprint(result)  # Err('Invalid number format: ...')\n</code></pre>"},{"location":"examples/#collecting-results","title":"Collecting Results","text":"<pre><code>from rustico import Ok, Err\n\ndef process_items(items: list) -&gt; list:\n    results = [process_item(item) for item in items]\n\n    # Filter out successful results\n    successful = [result.unwrap() for result in results if result.is_ok()]\n\n    # Collect errors\n    errors = [result.unwrap_err() for result in results if result.is_err()]\n\n    if errors:\n        print(f\"Warning: {len(errors)} items failed processing\")\n\n    return successful\n\ndef process_item(item):\n    # Process the item and return Ok or Err\n    pass\n</code></pre>"},{"location":"examples/#advanced-pattern-matching","title":"Advanced Pattern Matching","text":"<p>Python 3.10+ Feature</p> <p>Pattern matching requires Python 3.10 or later. For earlier versions, use conditional checks with <code>is_ok()</code> and <code>is_err()</code>.</p> <pre><code>from rustico import Ok, Err, as_result\n\n@as_result(ValueError, ZeroDivisionError)\ndef divide(a: int, b: int) -&gt; float:\n    return a / b\n\nresult = divide(10, 0)\n\nmatch result:\n    case Ok(value):\n        print(f\"Result: {value}\")\n    case Err(ZeroDivisionError() as e):\n        print(f\"Division by zero error: {e}\")\n    case Err(ValueError() as e):\n        print(f\"Value error: {e}\")\n    case Err(e):\n        print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"examples/#working-with-external-libraries","title":"Working with External Libraries","text":"<p>Integration Pattern</p> <p>When working with libraries that use exceptions, wrap their functions with <code>as_result</code> or use a try/except block that returns <code>Ok</code>/<code>Err</code>.</p> <pre><code>from rustico import Ok, Err, Result\nimport requests\n\ndef fetch_data(url: str) -&gt; Result[dict, Exception]:\n    try:\n        response = requests.get(url, timeout=5)\n        response.raise_for_status()\n        return Ok(response.json())\n    except requests.RequestException as e:\n        return Err(e)\n\n# Usage\nresult = fetch_data(\"https://api.example.com/data\")\ndata = result.unwrap_or({})\n</code></pre> <p>These examples demonstrate how <code>rustico</code> can be used in various real-world scenarios to make error handling more explicit, composable, and maintainable.</p>"},{"location":"examples/#feature-comparison","title":"Feature Comparison","text":"Feature Traditional Try/Except rustico Error Propagation Manual re-raising Automatic with <code>@do</code> Error Information Often lost in translation Preserved exactly Composability Nested try/except blocks Chainable operations Type Safety No static analysis Full type hints Pattern Matching Not applicable Native support Readability Often verbose and nested Linear and clear"},{"location":"examples/#next-steps","title":"Next Steps","text":"<ul> <li>Read the Quick Start guide for more examples</li> <li>Check the API Reference for detailed documentation</li> <li>Contribute to rustico to help improve the library</li> </ul> <p>Back to Top</p>"},{"location":"installation/","title":"Installation","text":"<p>Installing <code>rustico</code> is simple and straightforward. You can install it using pip, PDM, or Poetry.</p>"},{"location":"installation/#using-pip","title":"Using pip","text":"<pre><code>pip install rustico\n</code></pre>"},{"location":"installation/#using-pdm","title":"Using PDM","text":"<pre><code>pdm add rustico\n</code></pre>"},{"location":"installation/#using-poetry","title":"Using Poetry","text":"<pre><code>poetry add rustico\n</code></pre>"},{"location":"installation/#verifying-installation","title":"Verifying Installation","text":"<p>You can verify that <code>rustico</code> is installed correctly by running the following Python code:</p> <pre><code>from rustico import Ok, Err\n\nresult = Ok(42)\nprint(result)  # Should print: Ok(42)\n</code></pre>"},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>No additional dependencies required</li> </ul>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to <code>rustico</code>, you can install it in development mode:</p> <pre><code>git clone https://github.com/simwai/rustico.git\ncd rustico\npdm install\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>This guide will help you get started with <code>rustico</code> quickly. We'll cover the basics of using the <code>Result</code> type and show you how it compares to traditional error handling.</p>"},{"location":"quickstart/#the-problem-with-traditional-error-handling","title":"The Problem with Traditional Error Handling","text":"<p>Traditional error handling in Python using try/except blocks can be verbose, error-prone, and difficult to compose:</p> <pre><code>def process_user_data(user_id: str, age_str: str):\n    try:\n        user_id_int = int(user_id)\n    except ValueError:\n        return None  # Lost error information!\n\n    try:\n        age = int(age_str)\n    except ValueError:\n        return None  # Which field failed?\n\n    try:\n        if age &lt; 0:\n            raise ValueError(\"Age cannot be negative\")\n        return {\"user_id\": user_id_int, \"age\": age}\n    except ValueError:\n        return None  # Nested try/except hell!\n\n# Usage - You have to remember to check for None!\nresult = process_user_data(\"123\", \"25\")\nif result is None:  # But WHY did it fail?\n    print(\"Something went wrong...\")\n</code></pre>"},{"location":"quickstart/#the-rustico-way","title":"The <code>rustico</code> Way","text":"<p>With <code>rustico</code>, error handling becomes explicit, composable, and clear:</p> <pre><code>from rustico import as_result, do, Ok, Err\n\n@as_result(ValueError)\ndef parse_int(s: str) -&gt; int:\n    return int(s)\n\n@do\ndef process_user_data(user_id: str, age_str: str):\n    # Each step is explicit and composable\n    user_id_int = yield parse_int(user_id)\n    age = yield parse_int(age_str)\n\n    if age &lt; 0:\n        return Err(\"Age cannot be negative\")\n\n    return {\"user_id\": user_id_int, \"age\": age}\n\n# Usage - Errors are explicit and informative\nresult = process_user_data(\"123\", \"25\")\nmatch result:\n    case Ok(data):\n        print(f\"Success: {data}\")\n    case Err(error):\n        print(f\"Failed because: {error}\")\n</code></pre>"},{"location":"quickstart/#basic-usage-examples","title":"Basic Usage Examples","text":""},{"location":"quickstart/#1-wrapping-functions","title":"1. Wrapping Functions","text":"<pre><code>from rustico import as_result\n\n@as_result(ValueError)\ndef parse_int(s: str) -&gt; int:\n    return int(s)\n\nprint(parse_int(\"123\"))    # Ok(123)\nprint(parse_int(\"oops\"))   # Err(ValueError(...))\n</code></pre>"},{"location":"quickstart/#2-handling-results","title":"2. Handling Results","text":"<pre><code>result = parse_int(\"456\")\nif result.is_ok():\n    value = result.unwrap()\n    print(\"Got:\", value)\nelse:\n    error = result.unwrap_err()\n    print(\"Failed:\", error)\n</code></pre>"},{"location":"quickstart/#3-chaining-operations","title":"3. Chaining Operations","text":"<pre><code>from rustico import Ok, Err\n\ndef double(x: int):\n    return Ok(x * 2)\n\nresult = parse_int(\"21\").and_then(double)\nprint(result)  # Ok(42)\n</code></pre>"},{"location":"quickstart/#composing-multiple-steps-do-notation","title":"Composing Multiple Steps (do-notation)","text":"<pre><code>from rustico import as_result, do\n\n@do\ndef example():\n    # This yields Result[int, ValueError]\n    x = yield Ok(10)  # x receives the unwrapped int (type T)\n    y = yield Ok(20)  # y receives the unwrapped int (type T)\n    return x + y     \n\nprint(example())  # Ok(30)\n</code></pre>"},{"location":"quickstart/#early-exit-on-error","title":"Early Exit on Error","text":"<pre><code>@do\ndef safe_division(a: str, b: str):\n    x = yield parse_int(a)\n    y = yield parse_int(b)\n    if y == 0:\n        return Err(\"Division by zero\")\n    return x / y\n\nprint(safe_division(\"100\", \"0\"))   # Err('Division by zero')\nprint(safe_division(\"100\", \"5\"))   # Ok(20.0)\nprint(safe_division(\"foo\", \"5\"))   # Err(ValueError(...))\n</code></pre>"},{"location":"quickstart/#async-example","title":"Async Example","text":"<pre><code>import asyncio\nfrom rustico import as_async_result, do_async\n\n@as_async_result(ValueError)\nasync def parse_int_async(s: str) -&gt; int:\n    await asyncio.sleep(0.1)\n    return int(s)\n\n@do_async\nasync def compute_async():\n    a = yield await parse_int_async(\"100\")\n    b = yield await parse_int_async(\"23\")\n    return a + b\n\nasync def main():\n    result = await compute_async()\n    if result.is_ok():\n        print(\"Async sum:\", result.unwrap())\n    else:\n        print(\"Async error:\", result.unwrap_err())\n\nasyncio.run(main())  # Async sum: 123\n</code></pre>"},{"location":"quickstart/#mapping-and-error-transformation","title":"Mapping and Error Transformation","text":"<pre><code>result = parse_int(\"not a number\").map(lambda x: x * 2).map_err(str)\nprint(result)  # Err('invalid literal for int() with base 10: ...')\n</code></pre> <p>For more detailed examples and advanced usage, check out the Examples section.</p>"},{"location":"autoapi/summary/","title":"Summary","text":"<ul> <li>rustico<ul> <li>rustico</li> </ul> </li> </ul>"},{"location":"autoapi/rustico/","title":"rustico","text":""},{"location":"autoapi/rustico/#rustico.Err","title":"<code>Err</code>","text":"<p>               Bases: <code>Generic[E]</code></p> <p>A value that signifies failure and which stores arbitrary data for the error.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>class Err(Generic[E]):\n  \"\"\"A value that signifies failure and which stores arbitrary data for the error.\"\"\"\n\n  __match_args__ = ('err_value',)\n  __slots__ = ('_trace', '_value')\n\n  def __init__(self, value: E) -&gt; None:\n    self._value = value\n    self._trace: list[str] | None = self._capture_traceback(value)\n\n  def _capture_traceback(self, exc: E) -&gt; list[str] | None:\n    \"\"\"Capture traceback if the values is a BaseException with __traceback__.\"\"\"\n    if isinstance(exc, BaseException) and exc.__traceback__ is not None:\n      stack_summary = traceback.extract_tb(exc.__traceback__)\n      return traceback.format_list(stack_summary)\n    return None\n\n  @property\n  def trace(self) -&gt; list[str] | None:\n    \"\"\"Return the captured stack trace as a list of formatted strings.\"\"\"\n    return self._trace\n\n  def __repr__(self) -&gt; str:\n    return f'Err({self._value!r})'\n\n  def __eq__(self, other: Any) -&gt; bool:\n    return isinstance(other, Err) and self._value == other._value\n\n  def __ne__(self, other: Any) -&gt; bool:\n    return not (self == other)\n\n  def __hash__(self) -&gt; int:\n    return hash((False, self._value))\n\n  def is_ok(self) -&gt; Literal[False]:\n    return False\n\n  def is_err(self) -&gt; Literal[True]:\n    return True\n\n  def ok(self) -&gt; None:\n    \"\"\"Return `None`.\"\"\"\n    return None\n\n  def err(self) -&gt; E:\n    \"\"\"Return the error.\"\"\"\n    return self._value\n\n  @property\n  def err_value(self) -&gt; E:\n    \"\"\"Return the inner value.\"\"\"\n    return self._value\n\n  def swap(self) -&gt; Ok[E]:\n    \"\"\"Swap success/error cases. Returns `Ok` with the error value.\"\"\"\n    return Ok(self._value)\n\n  def value_or(self, default: U) -&gt; U:\n    \"\"\"Return the default value (alias for `unwrap_or`).\"\"\"\n    return default\n\n  def alt(self, op: Callable[[E], F]) -&gt; Err[F]:\n    \"\"\"Transform the error value using the given function.\"\"\"\n    return Err(op(self._value))\n\n  def expect(self, message: str) -&gt; NoReturn:\n    \"\"\"Raise an UnwrapError.\"\"\"\n    exc = UnwrapError(\n      self,\n      f'{message}: {self._value!r}',\n    )\n    if isinstance(self._value, BaseException):\n      raise exc from self._value\n    raise exc\n\n  def expect_err(self, _message: str) -&gt; E:\n    \"\"\"Return the inner value.\"\"\"\n    return self._value\n\n  def unwrap(self) -&gt; NoReturn:\n    \"\"\"Raise an UnwrapError.\"\"\"\n    exc = UnwrapError(\n      self,\n      f'Called `Result.unwrap()` on an `Err` value: {self._value!r}',\n    )\n    if isinstance(self._value, BaseException):\n      raise exc from self._value\n    raise exc\n\n  def unwrap_err(self) -&gt; E:\n    \"\"\"Return the inner value.\"\"\"\n    return self._value\n\n  def unwrap_or(self, default: U) -&gt; U:\n    \"\"\"Return the default value.\"\"\"\n    return default\n\n  def unwrap_or_else(self, op: Callable[[E], T]) -&gt; T:\n    \"\"\"Return the result of applying `op` to the error value.\"\"\"\n    return op(self._value)\n\n  def unwrap_or_raise(self, e: type[TBE]) -&gt; NoReturn:\n    \"\"\"Raise the exception with the error value.\"\"\"\n    raise e(self._value)\n\n  def map(self, op: object) -&gt; Err[E]:\n    \"\"\"Map the value (no-op for `Err`).\"\"\"\n    return self\n\n  async def map_async(self, op: object) -&gt; Err[E]:\n    \"\"\"Map the value asynchronously (no-op for `Err`).\"\"\"\n    return self\n\n  def map_or(self, default: U, op: object) -&gt; U:\n    \"\"\"Return the default value.\"\"\"\n    return default\n\n  def map_or_else(self, default_op: Callable[[], U], op: object) -&gt; U:\n    \"\"\"Return the result of the default operation.\"\"\"\n    return default_op()\n\n  def map_err(self, op: Callable[[E], F]) -&gt; Err[F]:\n    \"\"\"Map the error value using the given function.\"\"\"\n    return Err(op(self._value))\n\n  def and_then(self, op: object) -&gt; Err[E]:\n    \"\"\"Bind the error value (no-op for `Err`).\"\"\"\n    return self\n\n  async def and_then_async(self, op: object) -&gt; Err[E]:\n    \"\"\"Bind the error value asynchronously (no-op for `Err`).\"\"\"\n    return self\n\n  def or_else(self, op: Callable[[E], Result[T, F]]) -&gt; Result[T, F]:\n    \"\"\"Handle error case and return a new result.\"\"\"\n    return op(self._value)\n\n  def inspect(self, op: Callable[[T], Any]) -&gt; Result[T, E]:\n    \"\"\"Call a function with the value (no-op for `Err`).\"\"\"\n    return self\n\n  def inspect_err(self, op: Callable[[E], Any]) -&gt; Result[T, E]:\n    \"\"\"Call a function with the error value and return the original result.\"\"\"\n    op(self._value)\n    return self\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.err_value","title":"<code>err_value: E</code>  <code>property</code>","text":"<p>Return the inner value.</p>"},{"location":"autoapi/rustico/#rustico.Err.trace","title":"<code>trace: list[str] | None</code>  <code>property</code>","text":"<p>Return the captured stack trace as a list of formatted strings.</p>"},{"location":"autoapi/rustico/#rustico.Err.alt","title":"<code>alt(op)</code>","text":"<p>Transform the error value using the given function.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def alt(self, op: Callable[[E], F]) -&gt; Err[F]:\n  \"\"\"Transform the error value using the given function.\"\"\"\n  return Err(op(self._value))\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.and_then","title":"<code>and_then(op)</code>","text":"<p>Bind the error value (no-op for <code>Err</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def and_then(self, op: object) -&gt; Err[E]:\n  \"\"\"Bind the error value (no-op for `Err`).\"\"\"\n  return self\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.and_then_async","title":"<code>and_then_async(op)</code>  <code>async</code>","text":"<p>Bind the error value asynchronously (no-op for <code>Err</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>async def and_then_async(self, op: object) -&gt; Err[E]:\n  \"\"\"Bind the error value asynchronously (no-op for `Err`).\"\"\"\n  return self\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.err","title":"<code>err()</code>","text":"<p>Return the error.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def err(self) -&gt; E:\n  \"\"\"Return the error.\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.expect","title":"<code>expect(message)</code>","text":"<p>Raise an UnwrapError.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def expect(self, message: str) -&gt; NoReturn:\n  \"\"\"Raise an UnwrapError.\"\"\"\n  exc = UnwrapError(\n    self,\n    f'{message}: {self._value!r}',\n  )\n  if isinstance(self._value, BaseException):\n    raise exc from self._value\n  raise exc\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.expect_err","title":"<code>expect_err(_message)</code>","text":"<p>Return the inner value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def expect_err(self, _message: str) -&gt; E:\n  \"\"\"Return the inner value.\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.inspect","title":"<code>inspect(op)</code>","text":"<p>Call a function with the value (no-op for <code>Err</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def inspect(self, op: Callable[[T], Any]) -&gt; Result[T, E]:\n  \"\"\"Call a function with the value (no-op for `Err`).\"\"\"\n  return self\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.inspect_err","title":"<code>inspect_err(op)</code>","text":"<p>Call a function with the error value and return the original result.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def inspect_err(self, op: Callable[[E], Any]) -&gt; Result[T, E]:\n  \"\"\"Call a function with the error value and return the original result.\"\"\"\n  op(self._value)\n  return self\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.map","title":"<code>map(op)</code>","text":"<p>Map the value (no-op for <code>Err</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def map(self, op: object) -&gt; Err[E]:\n  \"\"\"Map the value (no-op for `Err`).\"\"\"\n  return self\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.map_async","title":"<code>map_async(op)</code>  <code>async</code>","text":"<p>Map the value asynchronously (no-op for <code>Err</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>async def map_async(self, op: object) -&gt; Err[E]:\n  \"\"\"Map the value asynchronously (no-op for `Err`).\"\"\"\n  return self\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.map_err","title":"<code>map_err(op)</code>","text":"<p>Map the error value using the given function.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def map_err(self, op: Callable[[E], F]) -&gt; Err[F]:\n  \"\"\"Map the error value using the given function.\"\"\"\n  return Err(op(self._value))\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.map_or","title":"<code>map_or(default, op)</code>","text":"<p>Return the default value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def map_or(self, default: U, op: object) -&gt; U:\n  \"\"\"Return the default value.\"\"\"\n  return default\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.map_or_else","title":"<code>map_or_else(default_op, op)</code>","text":"<p>Return the result of the default operation.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def map_or_else(self, default_op: Callable[[], U], op: object) -&gt; U:\n  \"\"\"Return the result of the default operation.\"\"\"\n  return default_op()\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.ok","title":"<code>ok()</code>","text":"<p>Return <code>None</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def ok(self) -&gt; None:\n  \"\"\"Return `None`.\"\"\"\n  return None\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.or_else","title":"<code>or_else(op)</code>","text":"<p>Handle error case and return a new result.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def or_else(self, op: Callable[[E], Result[T, F]]) -&gt; Result[T, F]:\n  \"\"\"Handle error case and return a new result.\"\"\"\n  return op(self._value)\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.swap","title":"<code>swap()</code>","text":"<p>Swap success/error cases. Returns <code>Ok</code> with the error value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def swap(self) -&gt; Ok[E]:\n  \"\"\"Swap success/error cases. Returns `Ok` with the error value.\"\"\"\n  return Ok(self._value)\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.unwrap","title":"<code>unwrap()</code>","text":"<p>Raise an UnwrapError.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap(self) -&gt; NoReturn:\n  \"\"\"Raise an UnwrapError.\"\"\"\n  exc = UnwrapError(\n    self,\n    f'Called `Result.unwrap()` on an `Err` value: {self._value!r}',\n  )\n  if isinstance(self._value, BaseException):\n    raise exc from self._value\n  raise exc\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.unwrap_err","title":"<code>unwrap_err()</code>","text":"<p>Return the inner value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap_err(self) -&gt; E:\n  \"\"\"Return the inner value.\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.unwrap_or","title":"<code>unwrap_or(default)</code>","text":"<p>Return the default value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap_or(self, default: U) -&gt; U:\n  \"\"\"Return the default value.\"\"\"\n  return default\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.unwrap_or_else","title":"<code>unwrap_or_else(op)</code>","text":"<p>Return the result of applying <code>op</code> to the error value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap_or_else(self, op: Callable[[E], T]) -&gt; T:\n  \"\"\"Return the result of applying `op` to the error value.\"\"\"\n  return op(self._value)\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.unwrap_or_raise","title":"<code>unwrap_or_raise(e)</code>","text":"<p>Raise the exception with the error value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap_or_raise(self, e: type[TBE]) -&gt; NoReturn:\n  \"\"\"Raise the exception with the error value.\"\"\"\n  raise e(self._value)\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Err.value_or","title":"<code>value_or(default)</code>","text":"<p>Return the default value (alias for <code>unwrap_or</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def value_or(self, default: U) -&gt; U:\n  \"\"\"Return the default value (alias for `unwrap_or`).\"\"\"\n  return default\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok","title":"<code>Ok</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A value that indicates success and which stores arbitrary data for the return value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>class Ok(Generic[T]):\n  \"\"\"\n  A value that indicates success and which stores arbitrary data for the return value.\n  \"\"\"\n\n  __match_args__ = ('ok_value',)\n  __slots__ = ('_value',)\n\n  def __init__(self, value: T) -&gt; None:\n    self._value = value\n\n  def __repr__(self) -&gt; str:\n    return f'Ok({self._value!r})'\n\n  def __eq__(self, other: Any) -&gt; bool:\n    return isinstance(other, Ok) and self._value == other._value\n\n  def __ne__(self, other: Any) -&gt; bool:\n    return not (self == other)\n\n  def __hash__(self) -&gt; int:\n    return hash((True, self._value))\n\n  def is_ok(self) -&gt; Literal[True]:\n    return True\n\n  def is_err(self) -&gt; Literal[False]:\n    return False\n\n  def ok(self) -&gt; T:\n    \"\"\"Return the value.\"\"\"\n    return self._value\n\n  def err(self) -&gt; None:\n    \"\"\"Return `None`.\"\"\"\n    return None\n\n  @property\n  def ok_value(self) -&gt; T:\n    \"\"\"Return the inner value.\"\"\"\n    return self._value\n\n  def swap(self) -&gt; Err[T]:\n    \"\"\"Swap success/error cases. Returns `Err` with the value.\"\"\"\n    return Err(self._value)\n\n  def value_or(self, default: Any) -&gt; T:\n    \"\"\"Return the value (alias for `unwrap_or`).\"\"\"\n    return self._value\n\n  def alt(self, op: Callable[[Any], Any]) -&gt; Ok[T]:\n    \"\"\"Transforms error value (no-op for `Ok`).\"\"\"\n    return self\n\n  def expect(self, _message: str) -&gt; T:\n    \"\"\"Return the value.\"\"\"\n    return self._value\n\n  def expect_err(self, message: str) -&gt; NoReturn:\n    \"\"\"Raise an UnwrapError since this type is `Ok`.\"\"\"\n    raise UnwrapError(self, message)\n\n  def unwrap(self) -&gt; T:\n    \"\"\"Return the value.\"\"\"\n    return self._value\n\n  def unwrap_err(self) -&gt; NoReturn:\n    \"\"\"Raise an UnwrapError since this type is `Ok`.\"\"\"\n    raise UnwrapError(self, 'Called `Result.unwrap_err()` on an `Ok` value')\n\n  def unwrap_or(self, _default: U) -&gt; T:\n    \"\"\"Return the value.\"\"\"\n    return self._value\n\n  def unwrap_or_else(self, op: Callable[[Any], T]) -&gt; T:\n    \"\"\"Return the value.\"\"\"\n    return self._value\n\n  def unwrap_or_raise(self, e: object) -&gt; T:\n    \"\"\"Return the value.\"\"\"\n    return self._value\n\n  def map(self, op: Callable[[T], U]) -&gt; Ok[U]:\n    \"\"\"Map the value using the given function.\"\"\"\n    return Ok(op(self._value))\n\n  async def map_async(self, op: Callable[[T], Awaitable[U]]) -&gt; Ok[U]:\n    \"\"\"Map the value asynchronously using the given function.\"\"\"\n    return Ok(await op(self._value))\n\n  def map_or(self, default: object, op: Callable[[T], U]) -&gt; U:\n    \"\"\"Map the value or return the default (not used for `Ok`).\"\"\"\n    return op(self._value)\n\n  def map_or_else(self, default_op: object, op: Callable[[T], U]) -&gt; U:\n    \"\"\"Map the value or run the default operation (not used for `Ok`).\"\"\"\n    return op(self._value)\n\n  def map_err(self, op: object) -&gt; Ok[T]:\n    \"\"\"Map the error value (no-op for `Ok`).\"\"\"\n    return self\n\n  def and_then(self, op: Callable[[T], Result[U, E]]) -&gt; Result[U, E]:\n    \"\"\"Bind the value to a function returning `Result`.\"\"\"\n    return op(self._value)\n\n  async def and_then_async(self, op: Callable[[T], Awaitable[Result[U, E]]]) -&gt; Result[U, E]:\n    \"\"\"Bind the value asynchronously to a function returning `Result`.\"\"\"\n    return await op(self._value)\n\n  def or_else(self, op: object) -&gt; Ok[T]:\n    \"\"\"Handle error case (no-op for `Ok`).\"\"\"\n    return self\n\n  def inspect(self, op: Callable[[T], Any]) -&gt; Result[T, E]:\n    \"\"\"Call a function with the value and return the original result.\"\"\"\n    op(self._value)\n    return self\n\n  def inspect_err(self, op: Callable[[E], Any]) -&gt; Result[T, E]:\n    \"\"\"Call a function with the error value (no-op for `Ok`).\"\"\"\n    return self\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.ok_value","title":"<code>ok_value: T</code>  <code>property</code>","text":"<p>Return the inner value.</p>"},{"location":"autoapi/rustico/#rustico.Ok.alt","title":"<code>alt(op)</code>","text":"<p>Transforms error value (no-op for <code>Ok</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def alt(self, op: Callable[[Any], Any]) -&gt; Ok[T]:\n  \"\"\"Transforms error value (no-op for `Ok`).\"\"\"\n  return self\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.and_then","title":"<code>and_then(op)</code>","text":"<p>Bind the value to a function returning <code>Result</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def and_then(self, op: Callable[[T], Result[U, E]]) -&gt; Result[U, E]:\n  \"\"\"Bind the value to a function returning `Result`.\"\"\"\n  return op(self._value)\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.and_then_async","title":"<code>and_then_async(op)</code>  <code>async</code>","text":"<p>Bind the value asynchronously to a function returning <code>Result</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>async def and_then_async(self, op: Callable[[T], Awaitable[Result[U, E]]]) -&gt; Result[U, E]:\n  \"\"\"Bind the value asynchronously to a function returning `Result`.\"\"\"\n  return await op(self._value)\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.err","title":"<code>err()</code>","text":"<p>Return <code>None</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def err(self) -&gt; None:\n  \"\"\"Return `None`.\"\"\"\n  return None\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.expect","title":"<code>expect(_message)</code>","text":"<p>Return the value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def expect(self, _message: str) -&gt; T:\n  \"\"\"Return the value.\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.expect_err","title":"<code>expect_err(message)</code>","text":"<p>Raise an UnwrapError since this type is <code>Ok</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def expect_err(self, message: str) -&gt; NoReturn:\n  \"\"\"Raise an UnwrapError since this type is `Ok`.\"\"\"\n  raise UnwrapError(self, message)\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.inspect","title":"<code>inspect(op)</code>","text":"<p>Call a function with the value and return the original result.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def inspect(self, op: Callable[[T], Any]) -&gt; Result[T, E]:\n  \"\"\"Call a function with the value and return the original result.\"\"\"\n  op(self._value)\n  return self\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.inspect_err","title":"<code>inspect_err(op)</code>","text":"<p>Call a function with the error value (no-op for <code>Ok</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def inspect_err(self, op: Callable[[E], Any]) -&gt; Result[T, E]:\n  \"\"\"Call a function with the error value (no-op for `Ok`).\"\"\"\n  return self\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.map","title":"<code>map(op)</code>","text":"<p>Map the value using the given function.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def map(self, op: Callable[[T], U]) -&gt; Ok[U]:\n  \"\"\"Map the value using the given function.\"\"\"\n  return Ok(op(self._value))\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.map_async","title":"<code>map_async(op)</code>  <code>async</code>","text":"<p>Map the value asynchronously using the given function.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>async def map_async(self, op: Callable[[T], Awaitable[U]]) -&gt; Ok[U]:\n  \"\"\"Map the value asynchronously using the given function.\"\"\"\n  return Ok(await op(self._value))\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.map_err","title":"<code>map_err(op)</code>","text":"<p>Map the error value (no-op for <code>Ok</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def map_err(self, op: object) -&gt; Ok[T]:\n  \"\"\"Map the error value (no-op for `Ok`).\"\"\"\n  return self\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.map_or","title":"<code>map_or(default, op)</code>","text":"<p>Map the value or return the default (not used for <code>Ok</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def map_or(self, default: object, op: Callable[[T], U]) -&gt; U:\n  \"\"\"Map the value or return the default (not used for `Ok`).\"\"\"\n  return op(self._value)\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.map_or_else","title":"<code>map_or_else(default_op, op)</code>","text":"<p>Map the value or run the default operation (not used for <code>Ok</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def map_or_else(self, default_op: object, op: Callable[[T], U]) -&gt; U:\n  \"\"\"Map the value or run the default operation (not used for `Ok`).\"\"\"\n  return op(self._value)\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.ok","title":"<code>ok()</code>","text":"<p>Return the value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def ok(self) -&gt; T:\n  \"\"\"Return the value.\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.or_else","title":"<code>or_else(op)</code>","text":"<p>Handle error case (no-op for <code>Ok</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def or_else(self, op: object) -&gt; Ok[T]:\n  \"\"\"Handle error case (no-op for `Ok`).\"\"\"\n  return self\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.swap","title":"<code>swap()</code>","text":"<p>Swap success/error cases. Returns <code>Err</code> with the value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def swap(self) -&gt; Err[T]:\n  \"\"\"Swap success/error cases. Returns `Err` with the value.\"\"\"\n  return Err(self._value)\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.unwrap","title":"<code>unwrap()</code>","text":"<p>Return the value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap(self) -&gt; T:\n  \"\"\"Return the value.\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.unwrap_err","title":"<code>unwrap_err()</code>","text":"<p>Raise an UnwrapError since this type is <code>Ok</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap_err(self) -&gt; NoReturn:\n  \"\"\"Raise an UnwrapError since this type is `Ok`.\"\"\"\n  raise UnwrapError(self, 'Called `Result.unwrap_err()` on an `Ok` value')\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.unwrap_or","title":"<code>unwrap_or(_default)</code>","text":"<p>Return the value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap_or(self, _default: U) -&gt; T:\n  \"\"\"Return the value.\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.unwrap_or_else","title":"<code>unwrap_or_else(op)</code>","text":"<p>Return the value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap_or_else(self, op: Callable[[Any], T]) -&gt; T:\n  \"\"\"Return the value.\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.unwrap_or_raise","title":"<code>unwrap_or_raise(e)</code>","text":"<p>Return the value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap_or_raise(self, e: object) -&gt; T:\n  \"\"\"Return the value.\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/#rustico.Ok.value_or","title":"<code>value_or(default)</code>","text":"<p>Return the value (alias for <code>unwrap_or</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def value_or(self, default: Any) -&gt; T:\n  \"\"\"Return the value (alias for `unwrap_or`).\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/#rustico.UnwrapError","title":"<code>UnwrapError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised from <code>.unwrap_&lt;...&gt;</code> and <code>.expect_&lt;...&gt;</code> calls.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>class UnwrapError(Exception):\n  \"\"\"\n  Exception raised from ``.unwrap_&lt;...&gt;`` and ``.expect_&lt;...&gt;`` calls.\n  \"\"\"\n\n  _result: Result[object, object]\n\n  def __init__(self, result: Result[object, object], message: str) -&gt; None:\n    self._result = result\n    super().__init__(message)\n\n  @property\n  def result(self) -&gt; Result[..., Any]:\n    \"\"\"Returns the original result.\"\"\"\n    return self._result\n</code></pre>"},{"location":"autoapi/rustico/#rustico.UnwrapError.result","title":"<code>result: Result[..., Any]</code>  <code>property</code>","text":"<p>Returns the original result.</p>"},{"location":"autoapi/rustico/#rustico.as_async_result","title":"<code>as_async_result(*exceptions)</code>","text":"<p>Make a decorator to turn an async function into one that returns a <code>Result</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def as_async_result(\n  *exceptions: type[TBE],\n) -&gt; Callable[[Callable[..., Awaitable[R]]], Callable[..., Awaitable[Result[R, TBE]]]]:\n  \"\"\"\n  Make a decorator to turn an async function into one that returns a ``Result``.\n  \"\"\"\n  if not exceptions or not all(\n    inspect.isclass(exception) and issubclass(exception, BaseException) for exception in exceptions\n  ):\n    raise TypeError('as_result() requires one or more exception types')\n\n  def decorator(\n    f: Callable[..., Awaitable[R]],\n  ) -&gt; Callable[..., Awaitable[Result[R, TBE]]]:\n    @functools.wraps(f)\n    async def async_wrapper(*args: ..., **kwargs: Any) -&gt; Result[R, TBE]:\n      try:\n        return Ok(await f(*args, **kwargs))\n      except exceptions as exc:\n        return Err(exc)\n\n    return async_wrapper\n\n  return decorator\n</code></pre>"},{"location":"autoapi/rustico/#rustico.as_result","title":"<code>as_result(*exceptions)</code>","text":"<p>Make a decorator to turn a function into one that returns a <code>Result</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def as_result(\n  *exceptions: type[TBE],\n) -&gt; Callable[[Callable[..., R]], Callable[..., Result[R, TBE]]]:\n  \"\"\"\n  Make a decorator to turn a function into one that returns a ``Result``.\n  \"\"\"\n  if not exceptions or not all(\n    inspect.isclass(exception) and issubclass(exception, BaseException) for exception in exceptions\n  ):\n    raise TypeError('as_result() requires one or more exception types')\n\n  def decorator(f: Callable[..., R]) -&gt; Callable[..., Result[R, TBE]]:\n    @functools.wraps(f)\n    def wrapper(*args: ..., **kwargs: Any) -&gt; Result[R, TBE]:\n      try:\n        return Ok(f(*args, **kwargs))\n      except exceptions as exc:\n        return Err(exc)\n\n    return wrapper\n\n  return decorator\n</code></pre>"},{"location":"autoapi/rustico/#rustico.catch","title":"<code>catch(*errors)</code>","text":"<p>Make a decorator to catch specified exceptions and return them as <code>Err</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def catch(\n  *errors: type[E],\n) -&gt; Callable[[Callable[..., T]], Callable[..., Result[T, E]]]:\n  \"\"\"\n  Make a decorator to catch specified exceptions and return them as ``Err``.\n  \"\"\"\n\n  def decorator(func: Callable[..., T]) -&gt; Callable[..., Result[T, E]]:\n    @functools.wraps(func)\n    def wrapper(*args: ..., **kwargs: Any) -&gt; Result[T, E]:\n      try:\n        result = func(*args, **kwargs)\n      except errors as e:\n        return Err(e)\n      return Ok(result)\n\n    return wrapper\n\n  return decorator\n</code></pre>"},{"location":"autoapi/rustico/#rustico.catch_async","title":"<code>catch_async(*errors)</code>","text":"<p>Make a decorator to catch specified exceptions in async functions and return them as <code>Err</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def catch_async(\n  *errors: type[E],\n) -&gt; Callable[[Callable[..., Awaitable[T]]], Callable[..., Awaitable[Result[T, E]]]]:\n  \"\"\"\n  Make a decorator to catch specified exceptions in async functions and return them as ``Err``.\n  \"\"\"\n\n  def decorator(\n    func: Callable[..., Awaitable[T]],\n  ) -&gt; Callable[..., Awaitable[Result[T, E]]]:\n    @functools.wraps(func)\n    async def wrapper(*args: ..., **kwargs: Any) -&gt; Result[T, E]:\n      try:\n        result = await func(*args, **kwargs)\n      except errors as e:\n        return Err(e)\n      return Ok(result)\n\n    return wrapper\n\n  return decorator\n</code></pre>"},{"location":"autoapi/rustico/#rustico.do","title":"<code>do(fn_or_gen)</code>","text":"<p>A dual-purpose function for emulating do-notation. Can be used as a decorator:</p> <p>@do def my_func() -&gt; Generator[...]:     ...</p> <p>Or as a helper function:</p> <p>my_gen = my_func() result = do(my_gen)</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def do(\n  fn_or_gen: Callable[..., Generator[Result[T, E], T, R]] | Generator[Result[T, E], T, R],\n) -&gt; Callable[[], Result[R, E]] | Result[R, E]:\n  \"\"\"\n  A dual-purpose function for emulating do-notation.\n  Can be used as a decorator:\n\n  @do\n  def my_func() -&gt; Generator[...]:\n      ...\n\n  Or as a helper function:\n\n  my_gen = my_func()\n  result = do(my_gen)\n  \"\"\"\n  if isinstance(fn_or_gen, Generator):\n    # Helper usage: do(my_generator)\n    return _run_do(fn_or_gen)\n\n  if callable(fn_or_gen):\n    # Decorator usage: @do\n    fn = fn_or_gen\n\n    @functools.wraps(fn)\n    def wrapper(*args: Any, **kwargs: Any) -&gt; Result[R, E]:\n      gen = fn(*args, **kwargs)\n      return _run_do(gen)\n\n    return wrapper\n\n  raise TypeError('do() must be used as a decorator or called with a generator instance.')\n</code></pre>"},{"location":"autoapi/rustico/#rustico.do_async","title":"<code>do_async(fn_or_gen)</code>","text":"<p>A dual-purpose function for emulating async do-notation.</p> <p>Can be used as a decorator: @do_async async def my_func() -&gt; AsyncGenerator[...]:     ...</p> <p>Or as a helper function: my_gen = my_func() result = await do_async(my_gen)</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def do_async(\n  fn_or_gen: Callable[..., AsyncGenerator[Result[T, E], None]] | AsyncGenerator[Result[T, E], None],\n) -&gt; Callable[..., Awaitable[Result[T, E]]] | Awaitable[Result[T, E]]:\n  \"\"\"\n  A dual-purpose function for emulating async do-notation.\n\n  Can be used as a decorator:\n  @do_async\n  async def my_func() -&gt; AsyncGenerator[...]:\n      ...\n\n  Or as a helper function:\n  my_gen = my_func()\n  result = await do_async(my_gen)\n  \"\"\"\n  if inspect.isasyncgen(fn_or_gen):\n    return _run_do_async(fn_or_gen)\n\n  if callable(fn_or_gen):\n    fn = fn_or_gen\n\n    @functools.wraps(fn)\n    async def wrapper(*args: ..., **kwargs: Any) -&gt; Result[T, E]:\n      async_gen = fn(*args, **kwargs)\n      return await _run_do_async(async_gen)\n\n    return wrapper\n\n  raise TypeError('do_async() must be used as a decorator or called with an async generator.')\n</code></pre>"},{"location":"autoapi/rustico/#rustico.is_err","title":"<code>is_err(result)</code>","text":"<p>Type guard to check if a result is an <code>Err</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def is_err(result: Result[T, E]) -&gt; TypeIs[Err[E]]:\n  \"\"\"Type guard to check if a result is an ``Err``.\"\"\"\n  return result.is_err()\n</code></pre>"},{"location":"autoapi/rustico/#rustico.is_ok","title":"<code>is_ok(result)</code>","text":"<p>Type guard to check if a result is an <code>Ok</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def is_ok(result: Result[T, E]) -&gt; TypeIs[Ok[T]]:\n  \"\"\"Type guard to check if a result is an ``Ok``.\"\"\"\n  return result.is_ok()\n</code></pre>"},{"location":"autoapi/rustico/#rustico.match","title":"<code>match(result, ok_handler, err_handler=None)</code>","text":"<p>Pattern match on a Result and apply the appropriate handler function.</p> <p>This function provides a functional alternative to Python's pattern matching syntax, allowing you to handle both success and error cases with dedicated handler functions. It's particularly useful when you want to transform the contents of a Result without unwrapping it first.</p> <p>:param result: The Result object to match against :type result: Result[T, E] :param ok_handler: Function to call if the Result is Ok :type ok_handler: Callable[[T], R] :param err_handler: Optional function to call if the Result is Err :type err_handler: Callable[[E], R] | None :return: The return value of the handler function that was called,          or None if the Result is Err and no err_handler was provided :rtype: R | None</p> <p>:Example - Basic usage:</p> <p>.. code-block:: python</p> <pre><code># Handle both success and error cases\nresult = Ok(42)\nmessage = match(result,\n               lambda value: f\"Success: {value}\",\n               lambda error: f\"Error: {error}\")\n# message == \"Success: 42\"\n\nresult = Err(\"failed\")\nmessage = match(result,\n               lambda value: f\"Success: {value}\",\n               lambda error: f\"Error: {error}\")\n# message == \"Error: failed\"\n</code></pre> <p>:Example - Transforming values:</p> <p>.. code-block:: python</p> <pre><code># Double a number if successful, or return 0 on error\nresult = Ok(21)\nnumber = match(result, lambda x: x * 2, lambda _: 0)\n# number == 42\n</code></pre> <p>:Example - Complex handling logic:</p> <p>.. code-block:: python</p> <pre><code>def process_ok(value):\n    if value &gt; 50:\n        return \"Large value\"\n    return \"Small value\"\n\ndef process_err(error):\n    if isinstance(error, str):\n        return f\"String error: {error}\"\n    return f\"Other error: {error}\"\n\n# Different handling based on value content\nresult1 = Ok(42)\nresult2 = Err(\"not found\")\n\nstatus1 = match(result1, process_ok, process_err)  # \"Small value\"\nstatus2 = match(result2, process_ok, process_err)  # \"String error: not found\"\n</code></pre> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def match(result: Result[T, E], ok_handler: Callable[[T], R], err_handler: Callable[[E], R] | None = None) -&gt; R | None:\n  \"\"\"Pattern match on a Result and apply the appropriate handler function.\n\n  This function provides a functional alternative to Python's pattern matching syntax,\n  allowing you to handle both success and error cases with dedicated handler functions.\n  It's particularly useful when you want to transform the contents of a Result without\n  unwrapping it first.\n\n  :param result: The Result object to match against\n  :type result: Result[T, E]\n  :param ok_handler: Function to call if the Result is Ok\n  :type ok_handler: Callable[[T], R]\n  :param err_handler: Optional function to call if the Result is Err\n  :type err_handler: Callable[[E], R] | None\n  :return: The return value of the handler function that was called,\n           or None if the Result is Err and no err_handler was provided\n  :rtype: R | None\n\n  :Example - Basic usage:\n\n  .. code-block:: python\n\n      # Handle both success and error cases\n      result = Ok(42)\n      message = match(result,\n                     lambda value: f\"Success: {value}\",\n                     lambda error: f\"Error: {error}\")\n      # message == \"Success: 42\"\n\n      result = Err(\"failed\")\n      message = match(result,\n                     lambda value: f\"Success: {value}\",\n                     lambda error: f\"Error: {error}\")\n      # message == \"Error: failed\"\n\n  :Example - Transforming values:\n\n  .. code-block:: python\n\n      # Double a number if successful, or return 0 on error\n      result = Ok(21)\n      number = match(result, lambda x: x * 2, lambda _: 0)\n      # number == 42\n\n  :Example - Complex handling logic:\n\n  .. code-block:: python\n\n      def process_ok(value):\n          if value &gt; 50:\n              return \"Large value\"\n          return \"Small value\"\n\n      def process_err(error):\n          if isinstance(error, str):\n              return f\"String error: {error}\"\n          return f\"Other error: {error}\"\n\n      # Different handling based on value content\n      result1 = Ok(42)\n      result2 = Err(\"not found\")\n\n      status1 = match(result1, process_ok, process_err)  # \"Small value\"\n      status2 = match(result2, process_ok, process_err)  # \"String error: not found\"\n  \"\"\"\n  if result.is_ok():\n    return ok_handler(result.unwrap())\n  elif err_handler is not None:\n    return err_handler(result.unwrap_err())\n  return None\n</code></pre>"},{"location":"autoapi/rustico/rustico/","title":"rustico","text":""},{"location":"autoapi/rustico/rustico/#rustico.rustico.DoException","title":"<code>DoException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Used to signal to <code>do()</code> that the result is an <code>Err</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>class DoException(Exception):\n  \"\"\"Used to signal to `do()` that the result is an `Err`.\"\"\"\n\n  def __init__(self, err: Err[E]) -&gt; None:\n    self.err = err\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err","title":"<code>Err</code>","text":"<p>               Bases: <code>Generic[E]</code></p> <p>A value that signifies failure and which stores arbitrary data for the error.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>class Err(Generic[E]):\n  \"\"\"A value that signifies failure and which stores arbitrary data for the error.\"\"\"\n\n  __match_args__ = ('err_value',)\n  __slots__ = ('_trace', '_value')\n\n  def __init__(self, value: E) -&gt; None:\n    self._value = value\n    self._trace: list[str] | None = self._capture_traceback(value)\n\n  def _capture_traceback(self, exc: E) -&gt; list[str] | None:\n    \"\"\"Capture traceback if the values is a BaseException with __traceback__.\"\"\"\n    if isinstance(exc, BaseException) and exc.__traceback__ is not None:\n      stack_summary = traceback.extract_tb(exc.__traceback__)\n      return traceback.format_list(stack_summary)\n    return None\n\n  @property\n  def trace(self) -&gt; list[str] | None:\n    \"\"\"Return the captured stack trace as a list of formatted strings.\"\"\"\n    return self._trace\n\n  def __repr__(self) -&gt; str:\n    return f'Err({self._value!r})'\n\n  def __eq__(self, other: Any) -&gt; bool:\n    return isinstance(other, Err) and self._value == other._value\n\n  def __ne__(self, other: Any) -&gt; bool:\n    return not (self == other)\n\n  def __hash__(self) -&gt; int:\n    return hash((False, self._value))\n\n  def is_ok(self) -&gt; Literal[False]:\n    return False\n\n  def is_err(self) -&gt; Literal[True]:\n    return True\n\n  def ok(self) -&gt; None:\n    \"\"\"Return `None`.\"\"\"\n    return None\n\n  def err(self) -&gt; E:\n    \"\"\"Return the error.\"\"\"\n    return self._value\n\n  @property\n  def err_value(self) -&gt; E:\n    \"\"\"Return the inner value.\"\"\"\n    return self._value\n\n  def swap(self) -&gt; Ok[E]:\n    \"\"\"Swap success/error cases. Returns `Ok` with the error value.\"\"\"\n    return Ok(self._value)\n\n  def value_or(self, default: U) -&gt; U:\n    \"\"\"Return the default value (alias for `unwrap_or`).\"\"\"\n    return default\n\n  def alt(self, op: Callable[[E], F]) -&gt; Err[F]:\n    \"\"\"Transform the error value using the given function.\"\"\"\n    return Err(op(self._value))\n\n  def expect(self, message: str) -&gt; NoReturn:\n    \"\"\"Raise an UnwrapError.\"\"\"\n    exc = UnwrapError(\n      self,\n      f'{message}: {self._value!r}',\n    )\n    if isinstance(self._value, BaseException):\n      raise exc from self._value\n    raise exc\n\n  def expect_err(self, _message: str) -&gt; E:\n    \"\"\"Return the inner value.\"\"\"\n    return self._value\n\n  def unwrap(self) -&gt; NoReturn:\n    \"\"\"Raise an UnwrapError.\"\"\"\n    exc = UnwrapError(\n      self,\n      f'Called `Result.unwrap()` on an `Err` value: {self._value!r}',\n    )\n    if isinstance(self._value, BaseException):\n      raise exc from self._value\n    raise exc\n\n  def unwrap_err(self) -&gt; E:\n    \"\"\"Return the inner value.\"\"\"\n    return self._value\n\n  def unwrap_or(self, default: U) -&gt; U:\n    \"\"\"Return the default value.\"\"\"\n    return default\n\n  def unwrap_or_else(self, op: Callable[[E], T]) -&gt; T:\n    \"\"\"Return the result of applying `op` to the error value.\"\"\"\n    return op(self._value)\n\n  def unwrap_or_raise(self, e: type[TBE]) -&gt; NoReturn:\n    \"\"\"Raise the exception with the error value.\"\"\"\n    raise e(self._value)\n\n  def map(self, op: object) -&gt; Err[E]:\n    \"\"\"Map the value (no-op for `Err`).\"\"\"\n    return self\n\n  async def map_async(self, op: object) -&gt; Err[E]:\n    \"\"\"Map the value asynchronously (no-op for `Err`).\"\"\"\n    return self\n\n  def map_or(self, default: U, op: object) -&gt; U:\n    \"\"\"Return the default value.\"\"\"\n    return default\n\n  def map_or_else(self, default_op: Callable[[], U], op: object) -&gt; U:\n    \"\"\"Return the result of the default operation.\"\"\"\n    return default_op()\n\n  def map_err(self, op: Callable[[E], F]) -&gt; Err[F]:\n    \"\"\"Map the error value using the given function.\"\"\"\n    return Err(op(self._value))\n\n  def and_then(self, op: object) -&gt; Err[E]:\n    \"\"\"Bind the error value (no-op for `Err`).\"\"\"\n    return self\n\n  async def and_then_async(self, op: object) -&gt; Err[E]:\n    \"\"\"Bind the error value asynchronously (no-op for `Err`).\"\"\"\n    return self\n\n  def or_else(self, op: Callable[[E], Result[T, F]]) -&gt; Result[T, F]:\n    \"\"\"Handle error case and return a new result.\"\"\"\n    return op(self._value)\n\n  def inspect(self, op: Callable[[T], Any]) -&gt; Result[T, E]:\n    \"\"\"Call a function with the value (no-op for `Err`).\"\"\"\n    return self\n\n  def inspect_err(self, op: Callable[[E], Any]) -&gt; Result[T, E]:\n    \"\"\"Call a function with the error value and return the original result.\"\"\"\n    op(self._value)\n    return self\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.err_value","title":"<code>err_value: E</code>  <code>property</code>","text":"<p>Return the inner value.</p>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.trace","title":"<code>trace: list[str] | None</code>  <code>property</code>","text":"<p>Return the captured stack trace as a list of formatted strings.</p>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.alt","title":"<code>alt(op)</code>","text":"<p>Transform the error value using the given function.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def alt(self, op: Callable[[E], F]) -&gt; Err[F]:\n  \"\"\"Transform the error value using the given function.\"\"\"\n  return Err(op(self._value))\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.and_then","title":"<code>and_then(op)</code>","text":"<p>Bind the error value (no-op for <code>Err</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def and_then(self, op: object) -&gt; Err[E]:\n  \"\"\"Bind the error value (no-op for `Err`).\"\"\"\n  return self\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.and_then_async","title":"<code>and_then_async(op)</code>  <code>async</code>","text":"<p>Bind the error value asynchronously (no-op for <code>Err</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>async def and_then_async(self, op: object) -&gt; Err[E]:\n  \"\"\"Bind the error value asynchronously (no-op for `Err`).\"\"\"\n  return self\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.err","title":"<code>err()</code>","text":"<p>Return the error.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def err(self) -&gt; E:\n  \"\"\"Return the error.\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.expect","title":"<code>expect(message)</code>","text":"<p>Raise an UnwrapError.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def expect(self, message: str) -&gt; NoReturn:\n  \"\"\"Raise an UnwrapError.\"\"\"\n  exc = UnwrapError(\n    self,\n    f'{message}: {self._value!r}',\n  )\n  if isinstance(self._value, BaseException):\n    raise exc from self._value\n  raise exc\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.expect_err","title":"<code>expect_err(_message)</code>","text":"<p>Return the inner value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def expect_err(self, _message: str) -&gt; E:\n  \"\"\"Return the inner value.\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.inspect","title":"<code>inspect(op)</code>","text":"<p>Call a function with the value (no-op for <code>Err</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def inspect(self, op: Callable[[T], Any]) -&gt; Result[T, E]:\n  \"\"\"Call a function with the value (no-op for `Err`).\"\"\"\n  return self\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.inspect_err","title":"<code>inspect_err(op)</code>","text":"<p>Call a function with the error value and return the original result.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def inspect_err(self, op: Callable[[E], Any]) -&gt; Result[T, E]:\n  \"\"\"Call a function with the error value and return the original result.\"\"\"\n  op(self._value)\n  return self\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.map","title":"<code>map(op)</code>","text":"<p>Map the value (no-op for <code>Err</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def map(self, op: object) -&gt; Err[E]:\n  \"\"\"Map the value (no-op for `Err`).\"\"\"\n  return self\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.map_async","title":"<code>map_async(op)</code>  <code>async</code>","text":"<p>Map the value asynchronously (no-op for <code>Err</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>async def map_async(self, op: object) -&gt; Err[E]:\n  \"\"\"Map the value asynchronously (no-op for `Err`).\"\"\"\n  return self\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.map_err","title":"<code>map_err(op)</code>","text":"<p>Map the error value using the given function.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def map_err(self, op: Callable[[E], F]) -&gt; Err[F]:\n  \"\"\"Map the error value using the given function.\"\"\"\n  return Err(op(self._value))\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.map_or","title":"<code>map_or(default, op)</code>","text":"<p>Return the default value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def map_or(self, default: U, op: object) -&gt; U:\n  \"\"\"Return the default value.\"\"\"\n  return default\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.map_or_else","title":"<code>map_or_else(default_op, op)</code>","text":"<p>Return the result of the default operation.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def map_or_else(self, default_op: Callable[[], U], op: object) -&gt; U:\n  \"\"\"Return the result of the default operation.\"\"\"\n  return default_op()\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.ok","title":"<code>ok()</code>","text":"<p>Return <code>None</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def ok(self) -&gt; None:\n  \"\"\"Return `None`.\"\"\"\n  return None\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.or_else","title":"<code>or_else(op)</code>","text":"<p>Handle error case and return a new result.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def or_else(self, op: Callable[[E], Result[T, F]]) -&gt; Result[T, F]:\n  \"\"\"Handle error case and return a new result.\"\"\"\n  return op(self._value)\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.swap","title":"<code>swap()</code>","text":"<p>Swap success/error cases. Returns <code>Ok</code> with the error value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def swap(self) -&gt; Ok[E]:\n  \"\"\"Swap success/error cases. Returns `Ok` with the error value.\"\"\"\n  return Ok(self._value)\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.unwrap","title":"<code>unwrap()</code>","text":"<p>Raise an UnwrapError.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap(self) -&gt; NoReturn:\n  \"\"\"Raise an UnwrapError.\"\"\"\n  exc = UnwrapError(\n    self,\n    f'Called `Result.unwrap()` on an `Err` value: {self._value!r}',\n  )\n  if isinstance(self._value, BaseException):\n    raise exc from self._value\n  raise exc\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.unwrap_err","title":"<code>unwrap_err()</code>","text":"<p>Return the inner value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap_err(self) -&gt; E:\n  \"\"\"Return the inner value.\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.unwrap_or","title":"<code>unwrap_or(default)</code>","text":"<p>Return the default value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap_or(self, default: U) -&gt; U:\n  \"\"\"Return the default value.\"\"\"\n  return default\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.unwrap_or_else","title":"<code>unwrap_or_else(op)</code>","text":"<p>Return the result of applying <code>op</code> to the error value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap_or_else(self, op: Callable[[E], T]) -&gt; T:\n  \"\"\"Return the result of applying `op` to the error value.\"\"\"\n  return op(self._value)\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.unwrap_or_raise","title":"<code>unwrap_or_raise(e)</code>","text":"<p>Raise the exception with the error value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap_or_raise(self, e: type[TBE]) -&gt; NoReturn:\n  \"\"\"Raise the exception with the error value.\"\"\"\n  raise e(self._value)\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Err.value_or","title":"<code>value_or(default)</code>","text":"<p>Return the default value (alias for <code>unwrap_or</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def value_or(self, default: U) -&gt; U:\n  \"\"\"Return the default value (alias for `unwrap_or`).\"\"\"\n  return default\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok","title":"<code>Ok</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A value that indicates success and which stores arbitrary data for the return value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>class Ok(Generic[T]):\n  \"\"\"\n  A value that indicates success and which stores arbitrary data for the return value.\n  \"\"\"\n\n  __match_args__ = ('ok_value',)\n  __slots__ = ('_value',)\n\n  def __init__(self, value: T) -&gt; None:\n    self._value = value\n\n  def __repr__(self) -&gt; str:\n    return f'Ok({self._value!r})'\n\n  def __eq__(self, other: Any) -&gt; bool:\n    return isinstance(other, Ok) and self._value == other._value\n\n  def __ne__(self, other: Any) -&gt; bool:\n    return not (self == other)\n\n  def __hash__(self) -&gt; int:\n    return hash((True, self._value))\n\n  def is_ok(self) -&gt; Literal[True]:\n    return True\n\n  def is_err(self) -&gt; Literal[False]:\n    return False\n\n  def ok(self) -&gt; T:\n    \"\"\"Return the value.\"\"\"\n    return self._value\n\n  def err(self) -&gt; None:\n    \"\"\"Return `None`.\"\"\"\n    return None\n\n  @property\n  def ok_value(self) -&gt; T:\n    \"\"\"Return the inner value.\"\"\"\n    return self._value\n\n  def swap(self) -&gt; Err[T]:\n    \"\"\"Swap success/error cases. Returns `Err` with the value.\"\"\"\n    return Err(self._value)\n\n  def value_or(self, default: Any) -&gt; T:\n    \"\"\"Return the value (alias for `unwrap_or`).\"\"\"\n    return self._value\n\n  def alt(self, op: Callable[[Any], Any]) -&gt; Ok[T]:\n    \"\"\"Transforms error value (no-op for `Ok`).\"\"\"\n    return self\n\n  def expect(self, _message: str) -&gt; T:\n    \"\"\"Return the value.\"\"\"\n    return self._value\n\n  def expect_err(self, message: str) -&gt; NoReturn:\n    \"\"\"Raise an UnwrapError since this type is `Ok`.\"\"\"\n    raise UnwrapError(self, message)\n\n  def unwrap(self) -&gt; T:\n    \"\"\"Return the value.\"\"\"\n    return self._value\n\n  def unwrap_err(self) -&gt; NoReturn:\n    \"\"\"Raise an UnwrapError since this type is `Ok`.\"\"\"\n    raise UnwrapError(self, 'Called `Result.unwrap_err()` on an `Ok` value')\n\n  def unwrap_or(self, _default: U) -&gt; T:\n    \"\"\"Return the value.\"\"\"\n    return self._value\n\n  def unwrap_or_else(self, op: Callable[[Any], T]) -&gt; T:\n    \"\"\"Return the value.\"\"\"\n    return self._value\n\n  def unwrap_or_raise(self, e: object) -&gt; T:\n    \"\"\"Return the value.\"\"\"\n    return self._value\n\n  def map(self, op: Callable[[T], U]) -&gt; Ok[U]:\n    \"\"\"Map the value using the given function.\"\"\"\n    return Ok(op(self._value))\n\n  async def map_async(self, op: Callable[[T], Awaitable[U]]) -&gt; Ok[U]:\n    \"\"\"Map the value asynchronously using the given function.\"\"\"\n    return Ok(await op(self._value))\n\n  def map_or(self, default: object, op: Callable[[T], U]) -&gt; U:\n    \"\"\"Map the value or return the default (not used for `Ok`).\"\"\"\n    return op(self._value)\n\n  def map_or_else(self, default_op: object, op: Callable[[T], U]) -&gt; U:\n    \"\"\"Map the value or run the default operation (not used for `Ok`).\"\"\"\n    return op(self._value)\n\n  def map_err(self, op: object) -&gt; Ok[T]:\n    \"\"\"Map the error value (no-op for `Ok`).\"\"\"\n    return self\n\n  def and_then(self, op: Callable[[T], Result[U, E]]) -&gt; Result[U, E]:\n    \"\"\"Bind the value to a function returning `Result`.\"\"\"\n    return op(self._value)\n\n  async def and_then_async(self, op: Callable[[T], Awaitable[Result[U, E]]]) -&gt; Result[U, E]:\n    \"\"\"Bind the value asynchronously to a function returning `Result`.\"\"\"\n    return await op(self._value)\n\n  def or_else(self, op: object) -&gt; Ok[T]:\n    \"\"\"Handle error case (no-op for `Ok`).\"\"\"\n    return self\n\n  def inspect(self, op: Callable[[T], Any]) -&gt; Result[T, E]:\n    \"\"\"Call a function with the value and return the original result.\"\"\"\n    op(self._value)\n    return self\n\n  def inspect_err(self, op: Callable[[E], Any]) -&gt; Result[T, E]:\n    \"\"\"Call a function with the error value (no-op for `Ok`).\"\"\"\n    return self\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.ok_value","title":"<code>ok_value: T</code>  <code>property</code>","text":"<p>Return the inner value.</p>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.alt","title":"<code>alt(op)</code>","text":"<p>Transforms error value (no-op for <code>Ok</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def alt(self, op: Callable[[Any], Any]) -&gt; Ok[T]:\n  \"\"\"Transforms error value (no-op for `Ok`).\"\"\"\n  return self\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.and_then","title":"<code>and_then(op)</code>","text":"<p>Bind the value to a function returning <code>Result</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def and_then(self, op: Callable[[T], Result[U, E]]) -&gt; Result[U, E]:\n  \"\"\"Bind the value to a function returning `Result`.\"\"\"\n  return op(self._value)\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.and_then_async","title":"<code>and_then_async(op)</code>  <code>async</code>","text":"<p>Bind the value asynchronously to a function returning <code>Result</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>async def and_then_async(self, op: Callable[[T], Awaitable[Result[U, E]]]) -&gt; Result[U, E]:\n  \"\"\"Bind the value asynchronously to a function returning `Result`.\"\"\"\n  return await op(self._value)\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.err","title":"<code>err()</code>","text":"<p>Return <code>None</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def err(self) -&gt; None:\n  \"\"\"Return `None`.\"\"\"\n  return None\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.expect","title":"<code>expect(_message)</code>","text":"<p>Return the value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def expect(self, _message: str) -&gt; T:\n  \"\"\"Return the value.\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.expect_err","title":"<code>expect_err(message)</code>","text":"<p>Raise an UnwrapError since this type is <code>Ok</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def expect_err(self, message: str) -&gt; NoReturn:\n  \"\"\"Raise an UnwrapError since this type is `Ok`.\"\"\"\n  raise UnwrapError(self, message)\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.inspect","title":"<code>inspect(op)</code>","text":"<p>Call a function with the value and return the original result.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def inspect(self, op: Callable[[T], Any]) -&gt; Result[T, E]:\n  \"\"\"Call a function with the value and return the original result.\"\"\"\n  op(self._value)\n  return self\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.inspect_err","title":"<code>inspect_err(op)</code>","text":"<p>Call a function with the error value (no-op for <code>Ok</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def inspect_err(self, op: Callable[[E], Any]) -&gt; Result[T, E]:\n  \"\"\"Call a function with the error value (no-op for `Ok`).\"\"\"\n  return self\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.map","title":"<code>map(op)</code>","text":"<p>Map the value using the given function.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def map(self, op: Callable[[T], U]) -&gt; Ok[U]:\n  \"\"\"Map the value using the given function.\"\"\"\n  return Ok(op(self._value))\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.map_async","title":"<code>map_async(op)</code>  <code>async</code>","text":"<p>Map the value asynchronously using the given function.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>async def map_async(self, op: Callable[[T], Awaitable[U]]) -&gt; Ok[U]:\n  \"\"\"Map the value asynchronously using the given function.\"\"\"\n  return Ok(await op(self._value))\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.map_err","title":"<code>map_err(op)</code>","text":"<p>Map the error value (no-op for <code>Ok</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def map_err(self, op: object) -&gt; Ok[T]:\n  \"\"\"Map the error value (no-op for `Ok`).\"\"\"\n  return self\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.map_or","title":"<code>map_or(default, op)</code>","text":"<p>Map the value or return the default (not used for <code>Ok</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def map_or(self, default: object, op: Callable[[T], U]) -&gt; U:\n  \"\"\"Map the value or return the default (not used for `Ok`).\"\"\"\n  return op(self._value)\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.map_or_else","title":"<code>map_or_else(default_op, op)</code>","text":"<p>Map the value or run the default operation (not used for <code>Ok</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def map_or_else(self, default_op: object, op: Callable[[T], U]) -&gt; U:\n  \"\"\"Map the value or run the default operation (not used for `Ok`).\"\"\"\n  return op(self._value)\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.ok","title":"<code>ok()</code>","text":"<p>Return the value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def ok(self) -&gt; T:\n  \"\"\"Return the value.\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.or_else","title":"<code>or_else(op)</code>","text":"<p>Handle error case (no-op for <code>Ok</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def or_else(self, op: object) -&gt; Ok[T]:\n  \"\"\"Handle error case (no-op for `Ok`).\"\"\"\n  return self\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.swap","title":"<code>swap()</code>","text":"<p>Swap success/error cases. Returns <code>Err</code> with the value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def swap(self) -&gt; Err[T]:\n  \"\"\"Swap success/error cases. Returns `Err` with the value.\"\"\"\n  return Err(self._value)\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.unwrap","title":"<code>unwrap()</code>","text":"<p>Return the value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap(self) -&gt; T:\n  \"\"\"Return the value.\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.unwrap_err","title":"<code>unwrap_err()</code>","text":"<p>Raise an UnwrapError since this type is <code>Ok</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap_err(self) -&gt; NoReturn:\n  \"\"\"Raise an UnwrapError since this type is `Ok`.\"\"\"\n  raise UnwrapError(self, 'Called `Result.unwrap_err()` on an `Ok` value')\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.unwrap_or","title":"<code>unwrap_or(_default)</code>","text":"<p>Return the value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap_or(self, _default: U) -&gt; T:\n  \"\"\"Return the value.\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.unwrap_or_else","title":"<code>unwrap_or_else(op)</code>","text":"<p>Return the value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap_or_else(self, op: Callable[[Any], T]) -&gt; T:\n  \"\"\"Return the value.\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.unwrap_or_raise","title":"<code>unwrap_or_raise(e)</code>","text":"<p>Return the value.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def unwrap_or_raise(self, e: object) -&gt; T:\n  \"\"\"Return the value.\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.Ok.value_or","title":"<code>value_or(default)</code>","text":"<p>Return the value (alias for <code>unwrap_or</code>).</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def value_or(self, default: Any) -&gt; T:\n  \"\"\"Return the value (alias for `unwrap_or`).\"\"\"\n  return self._value\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.UnwrapError","title":"<code>UnwrapError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised from <code>.unwrap_&lt;...&gt;</code> and <code>.expect_&lt;...&gt;</code> calls.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>class UnwrapError(Exception):\n  \"\"\"\n  Exception raised from ``.unwrap_&lt;...&gt;`` and ``.expect_&lt;...&gt;`` calls.\n  \"\"\"\n\n  _result: Result[object, object]\n\n  def __init__(self, result: Result[object, object], message: str) -&gt; None:\n    self._result = result\n    super().__init__(message)\n\n  @property\n  def result(self) -&gt; Result[..., Any]:\n    \"\"\"Returns the original result.\"\"\"\n    return self._result\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.UnwrapError.result","title":"<code>result: Result[..., Any]</code>  <code>property</code>","text":"<p>Returns the original result.</p>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.as_async_result","title":"<code>as_async_result(*exceptions)</code>","text":"<p>Make a decorator to turn an async function into one that returns a <code>Result</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def as_async_result(\n  *exceptions: type[TBE],\n) -&gt; Callable[[Callable[..., Awaitable[R]]], Callable[..., Awaitable[Result[R, TBE]]]]:\n  \"\"\"\n  Make a decorator to turn an async function into one that returns a ``Result``.\n  \"\"\"\n  if not exceptions or not all(\n    inspect.isclass(exception) and issubclass(exception, BaseException) for exception in exceptions\n  ):\n    raise TypeError('as_result() requires one or more exception types')\n\n  def decorator(\n    f: Callable[..., Awaitable[R]],\n  ) -&gt; Callable[..., Awaitable[Result[R, TBE]]]:\n    @functools.wraps(f)\n    async def async_wrapper(*args: ..., **kwargs: Any) -&gt; Result[R, TBE]:\n      try:\n        return Ok(await f(*args, **kwargs))\n      except exceptions as exc:\n        return Err(exc)\n\n    return async_wrapper\n\n  return decorator\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.as_result","title":"<code>as_result(*exceptions)</code>","text":"<p>Make a decorator to turn a function into one that returns a <code>Result</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def as_result(\n  *exceptions: type[TBE],\n) -&gt; Callable[[Callable[..., R]], Callable[..., Result[R, TBE]]]:\n  \"\"\"\n  Make a decorator to turn a function into one that returns a ``Result``.\n  \"\"\"\n  if not exceptions or not all(\n    inspect.isclass(exception) and issubclass(exception, BaseException) for exception in exceptions\n  ):\n    raise TypeError('as_result() requires one or more exception types')\n\n  def decorator(f: Callable[..., R]) -&gt; Callable[..., Result[R, TBE]]:\n    @functools.wraps(f)\n    def wrapper(*args: ..., **kwargs: Any) -&gt; Result[R, TBE]:\n      try:\n        return Ok(f(*args, **kwargs))\n      except exceptions as exc:\n        return Err(exc)\n\n    return wrapper\n\n  return decorator\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.catch","title":"<code>catch(*errors)</code>","text":"<p>Make a decorator to catch specified exceptions and return them as <code>Err</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def catch(\n  *errors: type[E],\n) -&gt; Callable[[Callable[..., T]], Callable[..., Result[T, E]]]:\n  \"\"\"\n  Make a decorator to catch specified exceptions and return them as ``Err``.\n  \"\"\"\n\n  def decorator(func: Callable[..., T]) -&gt; Callable[..., Result[T, E]]:\n    @functools.wraps(func)\n    def wrapper(*args: ..., **kwargs: Any) -&gt; Result[T, E]:\n      try:\n        result = func(*args, **kwargs)\n      except errors as e:\n        return Err(e)\n      return Ok(result)\n\n    return wrapper\n\n  return decorator\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.catch_async","title":"<code>catch_async(*errors)</code>","text":"<p>Make a decorator to catch specified exceptions in async functions and return them as <code>Err</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def catch_async(\n  *errors: type[E],\n) -&gt; Callable[[Callable[..., Awaitable[T]]], Callable[..., Awaitable[Result[T, E]]]]:\n  \"\"\"\n  Make a decorator to catch specified exceptions in async functions and return them as ``Err``.\n  \"\"\"\n\n  def decorator(\n    func: Callable[..., Awaitable[T]],\n  ) -&gt; Callable[..., Awaitable[Result[T, E]]]:\n    @functools.wraps(func)\n    async def wrapper(*args: ..., **kwargs: Any) -&gt; Result[T, E]:\n      try:\n        result = await func(*args, **kwargs)\n      except errors as e:\n        return Err(e)\n      return Ok(result)\n\n    return wrapper\n\n  return decorator\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.do","title":"<code>do(fn_or_gen)</code>","text":"<p>A dual-purpose function for emulating do-notation. Can be used as a decorator:</p> <p>@do def my_func() -&gt; Generator[...]:     ...</p> <p>Or as a helper function:</p> <p>my_gen = my_func() result = do(my_gen)</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def do(\n  fn_or_gen: Callable[..., Generator[Result[T, E], T, R]] | Generator[Result[T, E], T, R],\n) -&gt; Callable[[], Result[R, E]] | Result[R, E]:\n  \"\"\"\n  A dual-purpose function for emulating do-notation.\n  Can be used as a decorator:\n\n  @do\n  def my_func() -&gt; Generator[...]:\n      ...\n\n  Or as a helper function:\n\n  my_gen = my_func()\n  result = do(my_gen)\n  \"\"\"\n  if isinstance(fn_or_gen, Generator):\n    # Helper usage: do(my_generator)\n    return _run_do(fn_or_gen)\n\n  if callable(fn_or_gen):\n    # Decorator usage: @do\n    fn = fn_or_gen\n\n    @functools.wraps(fn)\n    def wrapper(*args: Any, **kwargs: Any) -&gt; Result[R, E]:\n      gen = fn(*args, **kwargs)\n      return _run_do(gen)\n\n    return wrapper\n\n  raise TypeError('do() must be used as a decorator or called with a generator instance.')\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.do_async","title":"<code>do_async(fn_or_gen)</code>","text":"<p>A dual-purpose function for emulating async do-notation.</p> <p>Can be used as a decorator: @do_async async def my_func() -&gt; AsyncGenerator[...]:     ...</p> <p>Or as a helper function: my_gen = my_func() result = await do_async(my_gen)</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def do_async(\n  fn_or_gen: Callable[..., AsyncGenerator[Result[T, E], None]] | AsyncGenerator[Result[T, E], None],\n) -&gt; Callable[..., Awaitable[Result[T, E]]] | Awaitable[Result[T, E]]:\n  \"\"\"\n  A dual-purpose function for emulating async do-notation.\n\n  Can be used as a decorator:\n  @do_async\n  async def my_func() -&gt; AsyncGenerator[...]:\n      ...\n\n  Or as a helper function:\n  my_gen = my_func()\n  result = await do_async(my_gen)\n  \"\"\"\n  if inspect.isasyncgen(fn_or_gen):\n    return _run_do_async(fn_or_gen)\n\n  if callable(fn_or_gen):\n    fn = fn_or_gen\n\n    @functools.wraps(fn)\n    async def wrapper(*args: ..., **kwargs: Any) -&gt; Result[T, E]:\n      async_gen = fn(*args, **kwargs)\n      return await _run_do_async(async_gen)\n\n    return wrapper\n\n  raise TypeError('do_async() must be used as a decorator or called with an async generator.')\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.is_err","title":"<code>is_err(result)</code>","text":"<p>Type guard to check if a result is an <code>Err</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def is_err(result: Result[T, E]) -&gt; TypeIs[Err[E]]:\n  \"\"\"Type guard to check if a result is an ``Err``.\"\"\"\n  return result.is_err()\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.is_ok","title":"<code>is_ok(result)</code>","text":"<p>Type guard to check if a result is an <code>Ok</code>.</p> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def is_ok(result: Result[T, E]) -&gt; TypeIs[Ok[T]]:\n  \"\"\"Type guard to check if a result is an ``Ok``.\"\"\"\n  return result.is_ok()\n</code></pre>"},{"location":"autoapi/rustico/rustico/#rustico.rustico.match","title":"<code>match(result, ok_handler, err_handler=None)</code>","text":"<p>Pattern match on a Result and apply the appropriate handler function.</p> <p>This function provides a functional alternative to Python's pattern matching syntax, allowing you to handle both success and error cases with dedicated handler functions. It's particularly useful when you want to transform the contents of a Result without unwrapping it first.</p> <p>:param result: The Result object to match against :type result: Result[T, E] :param ok_handler: Function to call if the Result is Ok :type ok_handler: Callable[[T], R] :param err_handler: Optional function to call if the Result is Err :type err_handler: Callable[[E], R] | None :return: The return value of the handler function that was called,          or None if the Result is Err and no err_handler was provided :rtype: R | None</p> <p>:Example - Basic usage:</p> <p>.. code-block:: python</p> <pre><code># Handle both success and error cases\nresult = Ok(42)\nmessage = match(result,\n               lambda value: f\"Success: {value}\",\n               lambda error: f\"Error: {error}\")\n# message == \"Success: 42\"\n\nresult = Err(\"failed\")\nmessage = match(result,\n               lambda value: f\"Success: {value}\",\n               lambda error: f\"Error: {error}\")\n# message == \"Error: failed\"\n</code></pre> <p>:Example - Transforming values:</p> <p>.. code-block:: python</p> <pre><code># Double a number if successful, or return 0 on error\nresult = Ok(21)\nnumber = match(result, lambda x: x * 2, lambda _: 0)\n# number == 42\n</code></pre> <p>:Example - Complex handling logic:</p> <p>.. code-block:: python</p> <pre><code>def process_ok(value):\n    if value &gt; 50:\n        return \"Large value\"\n    return \"Small value\"\n\ndef process_err(error):\n    if isinstance(error, str):\n        return f\"String error: {error}\"\n    return f\"Other error: {error}\"\n\n# Different handling based on value content\nresult1 = Ok(42)\nresult2 = Err(\"not found\")\n\nstatus1 = match(result1, process_ok, process_err)  # \"Small value\"\nstatus2 = match(result2, process_ok, process_err)  # \"String error: not found\"\n</code></pre> Source code in <code>src\\rustico\\rustico.py</code> <pre><code>def match(result: Result[T, E], ok_handler: Callable[[T], R], err_handler: Callable[[E], R] | None = None) -&gt; R | None:\n  \"\"\"Pattern match on a Result and apply the appropriate handler function.\n\n  This function provides a functional alternative to Python's pattern matching syntax,\n  allowing you to handle both success and error cases with dedicated handler functions.\n  It's particularly useful when you want to transform the contents of a Result without\n  unwrapping it first.\n\n  :param result: The Result object to match against\n  :type result: Result[T, E]\n  :param ok_handler: Function to call if the Result is Ok\n  :type ok_handler: Callable[[T], R]\n  :param err_handler: Optional function to call if the Result is Err\n  :type err_handler: Callable[[E], R] | None\n  :return: The return value of the handler function that was called,\n           or None if the Result is Err and no err_handler was provided\n  :rtype: R | None\n\n  :Example - Basic usage:\n\n  .. code-block:: python\n\n      # Handle both success and error cases\n      result = Ok(42)\n      message = match(result,\n                     lambda value: f\"Success: {value}\",\n                     lambda error: f\"Error: {error}\")\n      # message == \"Success: 42\"\n\n      result = Err(\"failed\")\n      message = match(result,\n                     lambda value: f\"Success: {value}\",\n                     lambda error: f\"Error: {error}\")\n      # message == \"Error: failed\"\n\n  :Example - Transforming values:\n\n  .. code-block:: python\n\n      # Double a number if successful, or return 0 on error\n      result = Ok(21)\n      number = match(result, lambda x: x * 2, lambda _: 0)\n      # number == 42\n\n  :Example - Complex handling logic:\n\n  .. code-block:: python\n\n      def process_ok(value):\n          if value &gt; 50:\n              return \"Large value\"\n          return \"Small value\"\n\n      def process_err(error):\n          if isinstance(error, str):\n              return f\"String error: {error}\"\n          return f\"Other error: {error}\"\n\n      # Different handling based on value content\n      result1 = Ok(42)\n      result2 = Err(\"not found\")\n\n      status1 = match(result1, process_ok, process_err)  # \"Small value\"\n      status2 = match(result2, process_ok, process_err)  # \"String error: not found\"\n  \"\"\"\n  if result.is_ok():\n    return ok_handler(result.unwrap())\n  elif err_handler is not None:\n    return err_handler(result.unwrap_err())\n  return None\n</code></pre>"}]}